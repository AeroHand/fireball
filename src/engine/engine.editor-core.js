(function () {
    var root = typeof global !== 'undefined' ? global : this;
    var Fire = root.Fire || {};
    var Editor = root.Editor || {};

    var JS = Fire.JS;
    var FObject = Fire.FObject;
    var HashObject = Fire.HashObject;
    var Asset = Fire.Asset;
    var Vec2 = Fire.Vec2;
    var v2 = Fire.v2;
    var Matrix23 = Fire.Matrix23;
    var Rect = Fire.Rect;
    var Color = Fire.Color;
    var Texture = Fire.Texture;
    var Sprite = Fire.Sprite;
    var Atlas = Fire.Atlas;

    // The codes below is generated by script automatically:
    // 

/**
 * show error stacks in unit tests
 * @method _throw
 * @param {Error} error
 * @private
 */
Fire._throw = function (error) {
    Fire.error(error.stack);
};

// Listen to assets change event, if changed, invoke Component's setters.
var AssetsWatcher = {
    initComponent: function () { },
    start: function () { },
    stop: function () { }
};

Editor._AssetsWatcher = AssetsWatcher;


///**
// * Overridable callbacks for editor, use `Fire.Engine._editorCallback` to access this module
// * @class _editorCallback
// * @static
// * @private
// */
var editorCallback = {


    onEnginePlayed: null,
    onEngineStopped: null,
    onEnginePaused: null,

    // This will be called before component callbacks
    onEntityCreated: null,

    /**
     * removes an entity and all its children from scene, this method will NOT be called if it is removed by hierarchy.
     * @param {Entity} entity - the entity to remove
     * @param {boolean} isTopMost - indicates whether it is the most top one among the entities who will be deleted in one operation
     */
    onEntityRemoved: null,

    onEntityParentChanged: null,

    /**
     * @param {Entity} entity
     * @param {number} oldIndex
     * @param {number} newIndex
     */
    onEntityIndexChanged: null,

    onEntityRenamed: null,

    /**
     * @param {Scene} scene
     */
    onStartUnloadScene: null,

    /**
     * @param {Scene} scene
     */
    onSceneLaunched: null,

    ///**
    // * @param {Scene} scene
    // */
    //onSceneLoaded: null,

    onComponentEnabled: null,
    onComponentDisabled: null,

    /**
     * @param {Entity} entity
     * @param {Component} component
     */
    onComponentAdded: null,

    /**
     * @param {Entity} entity
     * @param {Component} component
     */
    onComponentRemoved: null
};

// Mockers for editor-core

var ImageLoader, JsonLoader, TextLoader, _LoadFromXHR;
var ModifierKeyStates, KeyboardEvent, MouseEvent;

///**
// * !#en
// *
// * !#zh
// * ```
// * 本模块不含实际代码，仅仅为了声明本页面而定义。
// * ```
// *
// * @module Reserved-Words
// */

///**
// * @module Fire
// * @class Fire
// */

var Destroying = Fire._ObjectFlags.Destroying;
var DontDestroy = Fire._ObjectFlags.DontDestroy;
var Hide = Fire._ObjectFlags.Hide;
var HideInGame = Fire._ObjectFlags.HideInGame;
var HideInEditor = Fire._ObjectFlags.HideInEditor;


/**
 * !#zh 内容适配策略负责缩放摄像机画面以适应画布(Canvas)。
 * @class ContentStrategyType
 * @static
 */
var ContentStrategyType = Fire.defineEnum({

    /**
     * !#zh 不缩放内容，所有元素以原始大小显示在 Canvas 上。
     *
     * @property NoScale
     * @type number
     * @readOnly
     */
    NoScale: -1,

    ///**
    // * !#zh FixedWidth 模式会横向放大游戏世界以适应 Canvas 的宽度，纵向按原始宽高比放大。结果有可能导致放大（上下被裁剪），也有可能导致缩小（上下露出黑边）。
    // *
    // * @property FixedWidth
    // * @type number
    // * @readOnly
    // */
    //FixedWidth: -1,

    /**
     * !#en The application takes the height of the design resolution size and modifies the width of the internal canvas,
     * so that it fits the aspect ratio of the device and no distortion will occur,
     * however you must make sure your application works on different aspect ratios
     *
     * !#zh FixedHeight 模式会纵向放大游戏世界以适应 Canvas 的高度，横向按原始宽高比放大。结果有可能导致放大（左右被裁剪），也有可能导致缩小（左右露出黑边）。这是目前最推荐的适配方案。
     *
     * @property FixedHeight
     * @type number
     * @readOnly
     */
    FixedHeight: -1
});
Fire.ContentStrategyType = ContentStrategyType;

var __TESTONLY__ = {};
Fire.__TESTONLY__ = __TESTONLY__;
Fire._Runtime = {};
JS.getset(Fire._Runtime, 'RenderContext',
    function () {
        return RenderContext;
    },
    function (value) {
        RenderContext = value;
    }
);

/**
 * !#en The interface to get time information from Fireball.
 *
 * See [Time](/en/scripting/time/)
 * !#zh Time 模块用于获得游戏里的时间和帧率相关信息。直接使用 Fire.Time.*** 访问即可。
 *
 * 请参考教程[计时和帧率](/zh/scripting/time/)
 *
 * @class Time
 * @static
 */
var Time = (function () {
    var Time = {};

    /**
     * The time at the beginning of this frame. This is the time in seconds since the start of the game.
     * @property time
     * @type {number}
     * @readOnly
     */
    Time.time = 0;

    /**
     * The time at the beginning of this frame. This is the real time in seconds since the start of the game.
     *
     * `Time.realTime` not affected by time scale, and also keeps increasing while the player is paused in editor or in the background.
     * @property realTime
     * @type {number}
     * @readOnly
     */
    Time.realTime = 0;

    /**
     * The time in seconds it took to complete the last frame. Use this property to make your game frame rate independent.
     * @property deltaTime
     * @type {number}
     * @readOnly
     */
    Time.deltaTime = 0;

    /**
     * The total number of frames that have passed.
     * @property frameCount
     * @type {number}
     * @readOnly
     */
    Time.frameCount = 0;

    /**
     * The maximum time a frame can take.
     * @property maxDeltaTime
     * @type {number}
     * @readOnly
     */
    Time.maxDeltaTime = 0.3333333;

    var lastUpdateTime = 0;
    var startTime = 0;

    /**
     * @method Fire.Time._update
     * @param {boolean} [paused=false] if true, only realTime will be updated
     * @private
     */
    Time._update = function (timestamp, paused) {
        if (!paused) {
            var delta = timestamp - lastUpdateTime;
            delta = Math.min(Time.maxDeltaTime, delta);
            lastUpdateTime = timestamp;

            ++Time.frameCount;
            Time.deltaTime = delta;
            Time.time += delta;
        }
        Time.realTime = timestamp - startTime;
    };

    Time._restart = function (timestamp) {
        Time.time = 0;
        Time.realTime = 0;
        Time.deltaTime = 0;
        Time.frameCount = 0;
        lastUpdateTime = timestamp;
        startTime = timestamp;
    };

    return Time;
})();

Fire.Time = Time;

var Event = (function () {

    /**
     * An event allows for signaling that something has occurred. E.g. that an asset has completed downloading.
     * @class Event
     * @constructor
     * @param {string} type - The name of the event (case-sensitive), e.g. "click", "fire", or "submit"
     * @param {boolean} [bubbles=false] - A boolean indicating whether the event bubbles up through the tree or not
     */
    function Event (type, bubbles) {
        //HashObject.call(this);
        if (typeof bubbles === 'undefined') { bubbles = false; }

        /**
         * The name of the event (case-sensitive), e.g. "click", "fire", or "submit"
         * @property type
         * @type {string}
         */
        this.type = type;

        /**
         * A reference to the target to which the event was originally dispatched
         * @property target
         * @type {object}
         */
        this.target = null;

        /**
         * A reference to the currently registered target for the event
         * @property currentTarget;
         * @type {object}
         */
        this.currentTarget = null;

        /**
         * Indicates which phase of the event flow is currently being evaluated.
         * Returns an integer value represented by 4 constants:
         *  - Event.NONE = 0
         *  - Event.CAPTURING_PHASE = 1
         *  - Event.AT_TARGET = 2
         *  - Event.BUBBLING_PHASE = 3
         * The phases are explained in the [section 3.1, Event dispatch and DOM event flow]
         * (http://www.w3.org/TR/DOM-Level-3-Events/#event-flow), of the DOM Level 3 Events specification.
         *
         * @property eventPhase
         * @type {number}
         */
        this.eventPhase = 0;

        /**
         * A boolean indicating whether the event bubbles up through the hierarchy or not
         * @property bubbles
         * @type {boolean}
         */
        this.bubbles = bubbles;

        /**
         * Indicates whether or not event.preventDefault() has been called on the event
         * @property _defaultPrevented
         * @type {boolean}
         * @private
         */
        this._defaultPrevented = false;

        /**
         * Indicates whether or not event.stop() has been called on the event
         * @property _propagationStopped
         * @type {boolean}
         * @private
         */
        this._propagationStopped = false;

        /**
         * Indicates whether or not event.stop(true) has been called on the event
         * @property _propagationImmediateStopped
         * @type {boolean}
         * @private
         */
        this._propagationImmediateStopped = false;

        //this.cancelable = false;
        //this.clipboardData = undefined;
        //this.path = NodeList[0];
        //this.returnValue = true;
        //this.srcElement = null;
        //this.timeStamp = 1415761681529;
    }

    /**
	 * Events not currently dispatched are in this phase
	 * @property NONE
     * @type {number}
     * @static
     * @final
     */
    Event.NONE = 0;
    /**
	 * The capturing phase comprises the journey from the root to the last node before the event target's node
	 * see http://www.w3.org/TR/DOM-Level-3-Events/#event-flow
     * @property CAPTURING_PHASE
     * @type {number}
     * @static
     * @final
     */
    Event.CAPTURING_PHASE = 1;
    /**
	 * The target phase comprises only the event target node
	 * see http://www.w3.org/TR/DOM-Level-3-Events/#event-flow
     * @property AT_TARGET
     * @type {number}
     * @static
     * @final
     */
    Event.AT_TARGET = 2;
    /**
	 * The bubbling phase comprises any subsequent nodes encountered on the return trip to the root of the hierarchy
	 * see http://www.w3.org/TR/DOM-Level-3-Events/#event-flow
     * @property BUBBLING_PHASE
     * @type {number}
     * @static
     * @final
     */
    Event.BUBBLING_PHASE = 3;

    /**
     * Stop propagation. When dispatched in a tree, invoking this method prevents event from reaching any other objects than the current.
     *
     * @method stop
     * @param {boolean} [immediate=false] - Indicates whether or not to immediate stop the propagation, default is false.
     *                                      If true, for this particular event, no other callback will be called.
     *                                      Neither those attached on the same event target,
     *                                      nor those attached on targets which will be traversed later.
     */
    Event.prototype.stop = function (immediate) {
        this._propagationStopped = true;
        if (immediate) {
            this._propagationImmediateStopped = true;
        }
    };

    /**
     * If invoked when the cancelable attribute value is true, signals to the operation that caused event to be dispatched that it needs to be canceled.
     * @method preventDefault
     */
    Event.prototype.preventDefault = function () {
        this._defaultPrevented = true;
    };

    /**
     * @method _reset
     * @private
     */
    Event.prototype._reset = function () {
        this.target = null;
        this.currentTarget = null;
        this.eventPhase = 0;
        this._defaultPrevented = false;
        this._propagationStopped = false;
        this._propagationImmediateStopped = false;
    };

    return Event;
})();

Fire.Event = Event;

var EventListeners = (function () {

    /**
     * Extends Fire._CallbacksHandler to handle and invoke event callbacks.
     */
    function EventListeners () {
        Fire._CallbacksHandler.call(this);
    }
    JS.extend(EventListeners, Fire._CallbacksHandler);

    /**
     * @param {Event} event
     */
    EventListeners.prototype.invoke = function (event) {
        var list = this._callbackTable[event.type];
        if (list && list.length > 0) {
            if (list.length === 1) {
                list[0](event);
                return;
            }
            var endIndex = list.length - 1;
            var lastFunc = list[endIndex];
            for (var i = 0; i <= endIndex; ++i) {
                var callingFunc = list[i];
                callingFunc(event);
                if (event._propagationImmediateStopped || i === endIndex) {
                    break;
                }
                // 为了不每次触发消息时都创建一份回调数组的拷贝，这里需要对消息的反注册做检查和限制
                // check last one to see if any one removed
                if (list[endIndex] !== lastFunc) {          // 如果变短
                    if (list[endIndex - 1] === lastFunc) {  // 只支持删一个
                        if (list[i] !== callingFunc) {      // 如果删了前面的回调，索引不变
                            --i;
                        }
                        --endIndex;
                    }
                    else {
                        // 只允许在一个回调里面移除一个回调。如果要移除很多，只能用 event.stop(true)
                        Fire.error('Call event.stop(true) when you remove more than one callbacks in a event callback.');
                        return;
                    }
                }
            }
        }
    };

    return EventListeners;
})();

var EventTarget = (function () {

    /**
     * EventTarget is an object to which an event is dispatched when something has occurred.
     * Entity are the most common event targets, but other objects can be event targets too.
     *
     * Event targets are an important part of the Fireball event model.
     * The event target serves as the focal point for how events flow through the scene graph.
     * When an event such as a mouse click or a keypress occurs, Fireball dispatches an event object
     * into the event flow from the root of the hierarchy. The event object then makes its way through
     * the scene graph until it reaches the event target, at which point it begins its return trip through
     * the scene graph. This round-trip journey to the event target is conceptually divided into three phases:
     * - The capture phase comprises the journey from the root to the last node before the event target's node
     * - The target phase comprises only the event target node
     * - The bubbling phase comprises any subsequent nodes encountered on the return trip to the root of the tree
	 * See also: http://www.w3.org/TR/DOM-Level-3-Events/#event-flow
     *
     * Event targets can implement the following methods:
     *  - _getCapturingTargets
     *  - _getBubblingTargets
     *
     * @class EventTarget
     * @extends HashObject
     * @constructor
     */
    function EventTarget() {
        HashObject.call(this);

        /**
         * @property _capturingListeners
         * @type {EventListeners}
         * @default null
         * @private
         */
        this._capturingListeners = null;

        /**
         * @property _bubblingListeners
         * @type {EventListeners}
         * @default null
         * @private
         */
        this._bubblingListeners = null;
    }
    JS.extend(EventTarget, HashObject);

    /**
     * Register an callback of a specific event type on the EventTarget.
     * This method is merely an alias to addEventListener.
     *
     * @method on
     * @param {string} type - A string representing the event type to listen for.
     * @param {function} callback - The callback that will be invoked when the event is dispatched.
     *                              The callback is ignored if it is a duplicate (the callbacks are unique).
     * @param {Event} callback.param event
     * @param {boolean} [useCapture=false] - When set to true, the capture argument prevents callback
     *                              from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE.
     *                              When false, callback will NOT be invoked when event's eventPhase attribute value is CAPTURING_PHASE.
     *                              Either way, callback will be invoked when event's eventPhase attribute value is AT_TARGET.
     */
    EventTarget.prototype.on = function (type, callback, useCapture) {
        useCapture = typeof useCapture !== "undefined" ? useCapture : false;
        if (!callback) {
            Fire.error('Callback of event must be non-nil');
            return;
        }
        var listeners = null;
        if (useCapture) {
            listeners = this._capturingListeners = this._capturingListeners || new EventListeners();
        }
        else {
            listeners = this._bubblingListeners = this._bubblingListeners || new EventListeners();
        }
        if ( ! listeners.has(type, callback) ) {
            listeners.add(type, callback);
        }
    };

    /**
     * Removes the callback previously registered with the same type, callback, and capture.
     * This method is merely an alias to removeEventListener.
     *
     * @method off
     * @param {string} type - A string representing the event type being removed.
     * @param {function} callback - The callback to remove.
     * @param {boolean} [useCapture=false] - Specifies whether the callback being removed was registered as a capturing callback or not.
     *                              If not specified, useCapture defaults to false. If a callback was registered twice,
     *                              one with capture and one without, each must be removed separately. Removal of a capturing callback
     *                              does not affect a non-capturing version of the same listener, and vice versa.
     */
    EventTarget.prototype.off = function (type, callback, useCapture) {
        useCapture = typeof useCapture !== "undefined" ? useCapture : false;
        if (!callback) {
            return;
        }
        var listeners = useCapture ? this._capturingListeners : this._bubblingListeners;
        if (listeners) {
            listeners.remove(type, callback);
        }
    };

    /**
     * Register an callback of a specific event type on the EventTarget, the callback will remove itself after the first time it is triggered.
     *
     * @method once
     * @param {string} type - A string representing the event type to listen for.
     * @param {function} callback - The callback that will be invoked when the event is dispatched.
     *                              The callback is ignored if it is a duplicate (the callbacks are unique).
     * @param {Event} callback.param event
     * @param {boolean} [useCapture=false] - When set to true, the capture argument prevents callback
     *                              from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE.
     *                              When false, callback will NOT be invoked when event's eventPhase attribute value is CAPTURING_PHASE.
     *                              Either way, callback will be invoked when event's eventPhase attribute value is AT_TARGET.
     */
    EventTarget.prototype.once = function (type, callback, useCapture) {
        var self = this;
        var cb = function (event) {
            self.off(type, cb, useCapture);
            callback(event);
        };
        this.on(type, cb, useCapture);
    };

    ///**
    // * Checks whether the EventTarget object has any callback registered for a specific type of event.
    // *
    // * @param {string} type - The type of event.
    // * @param {boolean} A value of true if a callback of the specified type is registered; false otherwise.
    // */
    //EventTarget.prototype.hasEventListener = function (type) {};

    var cachedArray = new Array(16);
    cachedArray.length = 0;

    EventTarget.prototype._doDispatchEvent = function (event) {
        event.target = this;

        // Event.CAPTURING_PHASE
        this._getCapturingTargets(event.type, cachedArray);
        // propagate
        event.eventPhase = 1;
        var target, i;
        for (i = cachedArray.length - 1; i >= 0; --i) {
            target = cachedArray[i];
            if (target.isValid && target._capturingListeners) {
                event.currentTarget = target;
                // fire event
                target._capturingListeners.invoke(event);
                // check if propagation stopped
                if (event._propagationStopped) {
                    return;
                }
            }
        }
        cachedArray.length = 0;

        // Event.AT_TARGET
        // checks if destroyed in capturing callbacks
        if (this.isValid) {
            this._doSendEvent(event);
            if (event._propagationStopped) {
                return;
            }
        }

        if (event.bubbles) {
            // Event.BUBBLING_PHASE
            this._getBubblingTargets(event.type, cachedArray);
            // propagate
            event.eventPhase = 3;
            for (i = 0; i < cachedArray.length; ++i) {
                target = cachedArray[i];
                if (target.isValid && target._bubblingListeners) {
                    event.currentTarget = target;
                    // fire event
                    target._bubblingListeners.invoke(event);
                    // check if propagation stopped
                    if (event._propagationStopped) {
                        return;
                    }
                }
            }
        }
    };

    /**
     * Dispatches an event into the event flow. The event target is the EventTarget object upon which the dispatchEvent() method is called.
     *
     * @method dispatchEvent
     * @param {Event} event - The Event object that is dispatched into the event flow
     * @return {boolean} - returns true if either the event's preventDefault() method was not invoked,
     *                      or its cancelable attribute value is false, and false otherwise.
     */
    EventTarget.prototype.dispatchEvent = function (event) {
        this._doDispatchEvent(event);
        cachedArray.length = 0;
        var notPrevented = ! event._defaultPrevented;
        event._reset();
        return notPrevented;
    };

    /**
     * Send an event to this object directly, this method will not propagate the event to any other objects.
     *
     * @method _doSendEvent
     * @param {Event} event - The Event object that is sent to this event target.
     * @private
     */
    EventTarget.prototype._doSendEvent = function (event) {
        // Event.AT_TARGET
        event.eventPhase = 2;
        event.currentTarget = this;
        if (this._capturingListeners) {
            this._capturingListeners.invoke(event);
            if (event._propagationStopped) {
                return;
            }
        }
        if (this._bubblingListeners) {
            this._bubblingListeners.invoke(event);
        }
    };

    ///**
    // * Send an event to this object directly, this method will not propagate the event to any other objects.
    // *
    // * @param {Event} event - The Event object that is sent to this event target.
    // * @return {boolean} - returns true if either the event's preventDefault() method was not invoked,
    // *                      or its cancelable attribute value is false, and false otherwise.
    // */
    //EventTarget.prototype.sendEvent = function (event) {
    //    // Event.AT_TARGET
    //    event.reset();
    //    event.target = this;
    //    this._doSendEvent(event);
    //    return ! event._defaultPrevented;
    //};

    /**
     * Get all the targets listening to the supplied type of event in the target's capturing phase.
     * The capturing phase comprises the journey from the root to the last node BEFORE the event target's node.
     * The result should save in the array parameter, and MUST SORT from child nodes to parent nodes.
     *
     * Subclasses can override this method to make event propagable.
     *
     * @param {string} type - the event type
     * @param {array} array - the array to receive targets
     */
    EventTarget.prototype._getCapturingTargets = function (type, array) {
        /**
         * Subclasses can override this method to make event propagable, E.g.
         * ```
         * for (var target = this._parent; target; target = target._parent) {
         *     if (target._capturingListeners && target._capturingListeners.has(type)) {
         *         array.push(target);
         *     }
         * }
         * ```
         */
    };

    /**
     * Get all the targets listening to the supplied type of event in the target's bubbling phase.
	 * The bubbling phase comprises any SUBSEQUENT nodes encountered on the return trip to the root of the tree.
     * The result should save in the array parameter, and MUST SORT from child nodes to parent nodes.
     *
     * Subclasses can override this method to make event propagable.
     *
     * @param {string} type - the event type
     * @param {array} array - the array to receive targets
     */
    EventTarget.prototype._getBubblingTargets = function (type, array) {
        // Subclasses can override this method to make event propagable.
    };

    return EventTarget;
})();

Fire.EventTarget = EventTarget;

/**
 * The abstract renderer class which will be totally replaced with runtime implementation.
 * here just used as the mocker for unit tests.
 *
 * @class RenderContext
 * @constructor
 * @namespace _Runtime
 *
 * @param {number} width
 * @param {number} height
 * @param {Canvas} [canvas]
 * @param {boolean} [transparent = false]
 * @private
 */
var RenderContext = function (width, height, canvas, transparent) {
    this._camera = null;
    this._size = Fire.v2(width, height);
    this._canvas = canvas || document.createElement('canvas');
};

RenderContext.initRenderer = function (renderer) {
    renderer._renderObj = null;
    renderer._renderObjInScene = null;
    renderer._tempMatrix = new Fire.Matrix23();
};

// properties

Fire.JS.get(RenderContext.prototype, 'canvas',
    function () {
        return this._canvas;
    }
);

//Object.defineProperty(RenderContext.prototype, 'width', {
//    get: function () {
//        return this.width;
//    },
//    set: function (value) {
//        this.height = value;
//    }
//});
//
//Object.defineProperty(RenderContext.prototype, 'height', {
//    get: function () {
//        return this.renderer.height;
//    },
//    set: function (value) {
//        this.renderer.resize(this.renderer.width, value);
//    }
//});

Fire.JS.getset(RenderContext.prototype, 'size',
    function () {
        return this._size.clone();
    },
    function (value) {
        this._size = value.clone();
    }
);

//Object.defineProperty(RenderContext.prototype, 'background', {
//    set: function (value) {
//        this.stage.setBackgroundColor(value.toRGBValue());
//    }
//});

Fire.JS.getset(RenderContext.prototype, 'camera',
    function () {
        return this._camera;
    },
    function (value) {
        this._camera = value;
    }
);

Fire.JS.mixin(RenderContext.prototype, {

    onSceneLoaded: function (scene) { },
    onSceneLaunched: function (scene) { },

    /**
     * @param {Entity} entity
     * @param {number} oldIndex
     * @param {number} newIndex
     */
    onEntityIndexChanged: function (entity, oldIndex, newIndex) { },

    /**
     * @param {Entity} entity
     * @param {Entity} oldParent
     */
    onEntityParentChanged: function (entity, oldParent) {},

    /**
     * removes a entity and all its children from scene
     * @param {Entity} entity
     */
    onEntityRemoved: function (entity) { },

    /**
     * @param {Entity} entity
     */
    onRootEntityCreated: function (entity) { },

    /**
     * create pixi nodes recursively
     * @param {Entity} entity
     * @param {boolean} addToScene - add to pixi stage now if entity is root
     */
    onEntityCreated: function (entity, addToScene) {},

    /**
     * @param {SpriteRenderer} target
     */
    addSprite: function (target) {},

    /**
     * @param {SpriteRenderer} target
     * @param {boolean} show
     */
    show: function (target, show) {},

    /**
     * @param target {SpriteRenderer}
     * @param show {boolean}
     */
    remove: function (target) {},

    render: function () {},

    /**
     * Set the final transform to render
     * @param {SpriteRenderer} target
     * @param {Matrix23} matrix - the matrix to render (Read Only)
     */
    updateTransform: function (target, matrix) {},

    updateSpriteColor: function (target) {},

    /**
     * @param target {SpriteRenderer}
     */
    updateMaterial: function (target) {},

    /**
     * The debugging method that checks whether the render context matches the current scene or not.
     * @throws {string} error info
     */
    checkMatchCurrentScene: function () {}
});

Fire._Runtime.RenderContext = RenderContext;

var Component = (function () {

    /**
     * used in _callOnEnable to ensure onEnable and onDisable will be called alternately
     * 从逻辑上来说OnEnable和OnDisable的交替调用不需要由额外的变量进行保护，但那样会使设计变得复杂
     * 例如Entity.destroy调用后但还未真正销毁时，会调用所有Component的OnDisable。
     * 这时如果又有addComponent，Entity需要对这些新来的Component特殊处理。将来调度器做了之后可以尝试去掉这个标记。
     */
    var IsOnEnableCalled = Fire._ObjectFlags.IsOnEnableCalled;

    // IsOnEnableCalled 会收到 executeInEditMode 的影响，IsEditorOnEnabledCalled 不会
    var IsEditorOnEnabledCalled = Fire._ObjectFlags.IsEditorOnEnabledCalled;
    var IsOnLoadCalled = Fire._ObjectFlags.IsOnLoadCalled;
    var IsOnStartCalled = Fire._ObjectFlags.IsOnStartCalled;

    var compCtor;
    compCtor = function () {
        Editor._AssetsWatcher.initComponent(this);
    };
    /**
     * Base class for everything attached to Entity.
     *
     * NOTE: Not allowed to use construction parameters for Component's subclasses,
     *         because Component is created by the engine.
     *
     * @class Component
     * @extends HashObject
     * @constructor
     */
    var Component = Fire.extend('Fire.Component', HashObject, compCtor);

    /**
     * The entity this component is attached to. A component is always attached to an entity.
     * @property entity
     * @type {Entity}
     */
    Component.prop('entity', null, Fire.HideInInspector);

    // 如果不带有 uuid，则返回空字符串
    Component.getset('_scriptUuid',
        function () {
            return this._cacheUuid || '';
        },
        function (value) {
            if (this._cacheUuid !== value) {
                if (value && Editor.isUuid(value)) {
                    var classId = Editor.compressUuid(value);
                    var newComp = Fire.JS._getClassById(classId);
                    if (newComp) {
                        Fire.warn('Sorry, replacing component script is not yet implemented.');
                        //Editor.sendToWindows('reload:window-scripts', Editor._Sandbox.compiled);
                    }
                    else {
                        Fire.error('Can not find a component in the script which uuid is "%s".', value);
                    }
                }
                else {
                    Fire.error('invalid script');
                }
            }
        },
        Fire.DisplayName("Script"),
        Fire._ScriptUuid
    );

    /**
     * @property _enabled
     * @type boolean
     * @private
     */
    Component.prop('_enabled', true, Fire.HideInInspector);

    // properties

    /**
     * indicates whether this component is enabled or not.
     * @property enabled
     * @type boolean
     * @default true
     */
    Object.defineProperty(Component.prototype, 'enabled', {
        get: function () {
            return this._enabled;
        },
        set: function (value) {
            // jshint eqeqeq: false
            if (this._enabled != value) {
                // jshint eqeqeq: true
                this._enabled = value;
                if (this.entity._activeInHierarchy) {
                    _callOnEnable(this, value);
                }
            }
        }
    });

    /**
     * indicates whether this component is enabled and its entity is also active in the hierarchy.
     * @property enabledInHierarchy
     * @type {boolean}
     * @readOnly
     */
    Object.defineProperty(Component.prototype, 'enabledInHierarchy', {
        get: function () {
            return this._enabled && this.entity._activeInHierarchy;
        }
    });

    /**
     * Returns the {% crosslink Fire.Transform Transform %} attached to the entity.
     * @property transform
     * @type {Transform}
     * @readOnly
     */
    Object.defineProperty(Component.prototype, 'transform', {
        get: function () {
            return this.entity.transform;
        }
    });

    // callback functions

    /**
     * Update is called every frame, if the Component is enabled.
     * @event update
     */
    Component.prototype.update = null;

    /**
     * LateUpdate is called every frame, if the Component is enabled.
     * @event lateUpdate
     */
    Component.prototype.lateUpdate = null;
    //(NYI) Component.prototype.onCreate = null;  // customized constructor for template

    /**
     * When attaching to an active entity or its entity first activated
     * @event onLoad
     */
    Component.prototype.onLoad = null;

    /**
     * Called before all scripts' update if the Component is enabled
     * @event start
     */
    Component.prototype.start = null;

    /**
     * Called when this component becomes enabled and its entity becomes active
     * @event onEnable
     */
    Component.prototype.onEnable = null;

    /**
     * Called when this component becomes disabled or its entity becomes inactive
     * @event onDisable
     */
    Component.prototype.onDisable = null;

    /**
     * Called when this component will be destroyed.
     * @event onDestroy
     */
    Component.prototype.onDestroy = null;

    /**
     * Called when the engine starts rendering the scene.
     * @event onPreRender
     */
    Component.prototype.onPreRender = null;


    /**
     * Adds a component class to the entity. You can also add component to entity by passing in the name of the script.
     *
     * @method addComponent
     * @param {function|string} typeOrName - the constructor or the class name of the component to add
     * @return {Component} - the newly added component
     */
    Component.prototype.addComponent = function (typeOrTypename) {
        return this.entity.addComponent(typeOrTypename);
    };

    /**
     * Returns the component of supplied type if the entity has one attached, null if it doesn't. You can also get component in the entity by passing in the name of the script.
     *
     * @method getComponent
     * @param {function|string} typeOrName
     * @return {Component}
     */
    Component.prototype.getComponent = function (typeOrTypename) {
        return this.entity.getComponent(typeOrTypename);
    };

    ///**
    // * This method will be invoked when the scene graph changed, which is means the parent of its transform changed,
    // * or one of its ancestor's parent changed, or one of their sibling index changed.
    // * NOTE: This callback only available after onLoad.
    // *
    // * @param {Transform} transform - the transform which is changed, can be any of this transform's ancestor.
    // * @param {Transform} oldParent - the transform's old parent, if not changed, its sibling index changed.
    // * @return {boolean} return whether stop propagation to this component's child components.
    // */
    //Component.prototype.onHierarchyChanged = function (transform, oldParent) {};

    // overrides

    Component.prototype.destroy = function () {
        if (FObject.prototype.destroy.call(this)) {
            if (this._enabled && this.entity._activeInHierarchy) {
                _callOnEnable(this, false);
            }
        }
    };

    function call_FUNC_InTryCatch (c) {
        try {
            c._FUNC_();
        }
        catch (e) {
            Fire._throw(e);
        }
    }
    var execInTryCatchTmpl = '(' + call_FUNC_InTryCatch + ')';
    // jshint evil: true
    var callOnEnableInTryCatch = eval(execInTryCatchTmpl.replace(/_FUNC_/g, 'onEnable'));
    var callOnDisableInTryCatch = eval(execInTryCatchTmpl.replace(/_FUNC_/g, 'onDisable'));
    var callOnLoadInTryCatch = eval(execInTryCatchTmpl.replace(/_FUNC_/g, 'onLoad'));
    var callOnStartInTryCatch = eval(execInTryCatchTmpl.replace(/_FUNC_/g, 'start'));
    var callOnDestroyInTryCatch = eval(execInTryCatchTmpl.replace(/_FUNC_/g, 'onDestroy'));
    // jshint evil: false
    // Should not call onEnable/onDisable in other place
    function _callOnEnable (self, enable) {
        if ( enable ) {
            if ( !(self._objFlags & IsEditorOnEnabledCalled) ) {
                self._objFlags |= IsEditorOnEnabledCalled;
                if ( editorCallback.onComponentEnabled ) {
                    editorCallback.onComponentEnabled(self);
                }
            }
        }
        else {
            if ( self._objFlags & IsEditorOnEnabledCalled ) {
                self._objFlags &= ~IsEditorOnEnabledCalled;
                if ( editorCallback.onComponentDisabled ) {
                    editorCallback.onComponentDisabled(self);
                }
            }
        }
        if ( !(Fire.Engine.isPlaying || Fire.attr(self, 'executeInEditMode')) ) {
            return;
        }
        if ( enable ) {
            if ( !(self._objFlags & IsOnEnableCalled) ) {
                self._objFlags |= IsOnEnableCalled;
                if ( self.onEnable ) {
                    callOnEnableInTryCatch(self);
                }
            }

        }
        else {
            if ( self._objFlags & IsOnEnableCalled ) {
                self._objFlags &= ~IsOnEnableCalled;
                if ( self.onDisable ) {
                    callOnDisableInTryCatch(self);
                }
            }
        }
    }

    Component.prototype._onEntityActivated = function (active) {
        if ( !(this._objFlags & IsOnLoadCalled) && (Fire.Engine.isPlaying || Fire.attr(this, 'executeInEditMode')) ) {
            this._objFlags |= IsOnLoadCalled;
            if (this.onLoad) {
                callOnLoadInTryCatch(this);
            }
            Editor._AssetsWatcher.start(this);
            //if (this.onHierarchyChanged) {
            //    this.entity.transform._addListener(this);
            //}
        }
        if (this._enabled) {
            _callOnEnable(this, active);
        }
    };

    /**
     * invoke starts on entities
     * @param {Entity} entity
     */
    Component._invokeStarts = function (entity) {
        var countBefore = entity._components.length;
        var c = 0, comp = null;
        if (Fire.Engine.isPlaying) {
            for (; c < countBefore; ++c) {
                comp = entity._components[c];
                if ( !(comp._objFlags & IsOnStartCalled) ) {
                    comp._objFlags |= IsOnStartCalled;
                    if (comp.start) {
                        callOnStartInTryCatch(comp);
                    }
                }
            }
        }
        else {
            for (; c < countBefore; ++c) {
                comp = entity._components[c];
                if ( !(comp._objFlags & IsOnStartCalled) && Fire.attr(comp, 'executeInEditMode')) {
                    comp._objFlags |= IsOnStartCalled;
                    if (comp.start) {
                        callOnStartInTryCatch(comp);
                    }
                }
            }
        }
        // activate its children recursively
        for (var i = 0, children = entity._children, len = children.length; i < len; ++i) {
            var child = children[i];
            if (child._active) {
                Component._invokeStarts(child);
            }
        }
    };

    Component.prototype._onPreDestroy = function () {
        // ensure onDisable called
        _callOnEnable(this, false);
        // onDestroy
        Editor._AssetsWatcher.stop(this);
        if (Fire.Engine.isPlaying || Fire.attr(this, 'executeInEditMode')) {
            if (this.onDestroy) {
                callOnDestroyInTryCatch(this);
            }
        }
        // remove component
        this.entity._removeComponent(this);
    };

    return Component;
})();

Fire.Component = Component;

////////////////////////////////////////////////////////////////////////////////
// Component helpers

// Register Component Menu

Fire._componentMenuItems = [];
/**
 * @class Fire
 */
/**
 * Register a component to the "Component" menu.
 *
 * @method addComponentMenu
 * @param {function} constructor - the class you want to register, must inherit from Component
 * @param {string} menuPath - the menu path name. Eg. "Rendering/Camera"
 * @param {number} [priority] - the order which the menu item are displayed
 */
Fire.addComponentMenu = function (constructor, menuPath, priority) {
    if ( !Fire.isChildClassOf(constructor, Component) ) {
        Fire.error('[Fire.addComponentMenu] constructor must inherit from Component');
        return;
    }
    Fire._componentMenuItems.push({
        component: constructor,
        menuPath: menuPath,
        priority: priority
    });
};

Fire.attr(Component, 'executeInEditMode', false);
/**
 * Makes a component execute in edit mode.
 * By default, all components are only executed in play mode,
 * which means they will not have their callback functions executed while the Editor is in edit mode.
 * By calling this function, each component will also have its callback executed in edit mode.
 *
 * @method executeInEditMode
 * @param {Component} constructor - the class you want to register, must inherit from Component
 */
Fire.executeInEditMode = function (constructor) {
    if ( !Fire.isChildClassOf(constructor, Component) ) {
        Fire.error('[Fire.executeInEditMode] constructor must inherit from Component');
        return;
    }
    Fire.attr(constructor, 'executeInEditMode', true);
};

var _requiringFrames = [];  // the requiring frame infos

Fire._RFpush = function (module, uuid, script) {
    if (arguments.length === 2) {
        script = uuid;
        uuid = '';
    }
    _requiringFrames.push({
        uuid: uuid,
        script: script,
        module: module,
        exports: module.exports,    // original exports
        comp: null
    });
};

Fire._RFpop = function () {
    var frameInfo = _requiringFrames.pop();
    // check exports
    var module = frameInfo.module;
    var exports = frameInfo.exports;
    if (exports === module.exports) {
        for (var key in exports) {
            return;
        }
        // auto export component
        module.exports = frameInfo.comp;
    }
};

Fire._RFget = function () {
    return _requiringFrames[_requiringFrames.length - 1];
};


function checkCompCtor (constructor, scopeName) {
    if (constructor) {
        if (Fire.isChildClassOf(constructor, Component)) {
            Fire.error(scopeName + ' Constructor can not be another Component');
            return false;
        }
        if (constructor.length > 0) {
            // To make a unified FireClass serialization process,
            // we don't allow parameters for constructor when creating instances of FireClass.
            // For advance user, construct arguments can get from 'arguments'.
            Fire.error(scopeName + ' Can not instantiate Component with arguments.');
            return false;
        }
    }
    return true;
}
var doDefine = Fire._doDefine;
Fire._doDefine = function (className, baseClass, constructor) {
    if ( Fire.isChildClassOf(baseClass, Fire.Component) ) {
        var frame = Fire._RFget();
        if (frame) {
            if ( !checkCompCtor(constructor, '[Fire.extend]') ) {
                return null;
            }
            if (frame.comp) {
                Fire.error('Sorry, each script can have at most one Component.');
                return;
            }
            if (frame.uuid) {
                // project component
                if (className) {
                    Fire.warn('Sorry, specifying class name for Component in project scripts is not allowed.');
                }
            }
            //else {
            //    builtin plugin component
            //}
            className = className || frame.script;
            var cls = doDefine(className, baseClass, constructor);
            if (frame.uuid) {
                JS._setClassId(frame.uuid, cls);
            }
            frame.comp = cls;
            return cls;
        }
    }
    // not component or engine component
    return doDefine(className, baseClass, constructor);
};

var Transform = (function () {

    /**
     * Defines position, rotation and scale of an entity.
     *
     * @class Transform
     * @extends Component
     * @constructor
     */
    var Transform = Fire.extend('Fire.Transform', Component, function () {
        /**
         * @property _position;
         * @type {Vec2}
         * @default new Vec2(0, 0)
         * @private
         */
        this._position = new Vec2(0, 0);
        /**
         * @property _scale;
         * @type {Vec2}
         * @default new Vec2(1, 1)
         * @private
         */
        this._scale = new Vec2(1, 1);

        this._worldTransform = new Matrix23();

        /**
         * the cached reference to parent transform
         * @property _parent
         * @type {Transform}
         * @default null
         * @private
         */
        this._parent = null;

        //this._hierarchyChangedListeners = null;
    });

    Fire.executeInEditMode(Transform);

    Transform.prop('_position', null, Fire.HideInInspector);
    Transform.prop('_rotation', 0, Fire.HideInInspector);
    Transform.prop('_scale', null, Fire.HideInInspector);

    // properties

    var ERR_NaN = 'The %s must not be NaN';

    /**
     * The local position in its parent's coordinate system
     * @property position
     * @type {Vec2}
     * @default new Vec2(0, 0)
     */
    Transform.getset('position',
        function () {
            return new Vec2(this._position.x, this._position.y);
        },
        function (value) {
            var x = value.x;
            var y = value.y;
            if ( !isNaN(x) && !isNaN(y) ) {
                this._position.x = x;
                this._position.y = y;
            }
            else {
                Fire.error(ERR_NaN, 'xy of new position');
            }
        },
        Fire.Tooltip("The local position in its parent's coordinate system")
    );

    /**
     * The local x position in its parent's coordinate system
     * @property x
     * @type {number}
     * @default 0
     */
    Object.defineProperty(Transform.prototype, 'x', {
        get: function () {
            return this._position.x;
        },
        set: function (value) {
            if ( !isNaN(value) ) {
                this._position.x = value;
                // notify change
                this._position = this._position;
            }
            else {
                Fire.error(ERR_NaN, 'new x');
            }
        }
    });

    /**
     * The local y position in its parent's coordinate system
     * @property y
     * @type {number}
     * @default 0
     */
    Object.defineProperty(Transform.prototype, 'y', {
        get: function () {
            return this._position.y;
        },
        set: function (value) {
            if ( !isNaN(value) ) {
                this._position.y = value;
                // notify change
                this._position = this._position;
            }
            else {
                Fire.error(ERR_NaN, 'new y');
            }
        }
    });

    /**
     * The position of the transform in world space
     * @property worldPosition
     * @type {Vec2}
     * @default new Vec2(0, 0)
     */
    Object.defineProperty(Transform.prototype, 'worldPosition', {
        get: function () {
            var l2w = this.getLocalToWorldMatrix();
            return new Vec2(l2w.tx, l2w.ty);
        },
        set: function (value) {
            var x = value.x;
            var y = value.y;
            if ( !isNaN(x) && !isNaN(y) ) {
                if ( this._parent ) {
                    var w2l = this._parent.getWorldToLocalMatrix();
                    this.position = w2l.transformPoint(value);
                }
                else {
                    this.position = value;
                }
            }
            else {
                Fire.error(ERR_NaN, 'xy of new worldPosition');
            }
        }
    });

    /**
     * The x position of the transform in world space
     * @property worldX
     * @type {number}
     * @default 0
     */
    Object.defineProperty(Transform.prototype, 'worldX', {
        get: function () {
            return this.worldPosition.x;
        },
        set: function (value) {
            if ( !isNaN(value) ) {
                if ( this._parent ) {
                    var pl2w = this._parent.getLocalToWorldMatrix();
                    var l2w = this.getLocalMatrix().prepend(pl2w);
                    if (l2w.tx !== value) {
                        this._position.x = value;
                        this._position.y = l2w.ty;
                        pl2w.invert().transformPoint(this._position, this._position);
                    }
                }
                else {
                    this._position.x = value;
                }
                // notify change
                this._position = this._position;
                //将来优化做好了以后，上面的代码可以简化成下面这些
                //var pos = this.worldPosition;
                //if (pos.x !== value) {
                //    pos.x = value;
                //    this.worldPosition = pos;
                //}
            }
            else {
                Fire.error(ERR_NaN, 'new worldX');
            }
        }
    });

    /**
     * The y position of the transform in world space
     * @property worldY
     * @type {number}
     * @default 0
     */
    Object.defineProperty(Transform.prototype, 'worldY', {
        get: function () {
            return this.worldPosition.y;
        },
        set: function (value) {
            if ( !isNaN(value) ) {
                if ( this._parent ) {
                    var pl2w = this._parent.getLocalToWorldMatrix();
                    var l2w = this.getLocalMatrix().prepend(pl2w);
                    if (l2w.ty !== value) {
                        this._position.x = l2w.tx;
                        this._position.y = value;
                        pl2w.invert().transformPoint(this._position, this._position);
                    }
                }
                else {
                    this._position.y = value;
                }
                // notify change
                this._position = this._position;
            }
            else {
                Fire.error(ERR_NaN, 'new worldY');
            }
        }
    });

    /**
     * The counterclockwise degrees of rotation relative to the parent
     * @property rotation
     * @type {number}
     * @default 0
     */
    Transform.getset('rotation',
        function () {
            return this._rotation;
        },
        function (value) {
            if ( !isNaN(value) ) {
                this._rotation = value;
            }
            else {
                Fire.error(ERR_NaN, 'new rotation');
            }
        },
        Fire.Tooltip('The counterclockwise degrees of rotation relative to the parent')
    );

    /**
     * The counterclockwise degrees of rotation in world space
     * @property worldRotation
     * @type {number}
     * @default 0
     */
    Object.defineProperty(Transform.prototype, 'worldRotation', {
        get: function () {
            if ( this._parent ) {
                return this.rotation + this._parent.worldRotation;
            }
            else {
                return this.rotation;
            }
        },
        set: function (value) {
            if ( !isNaN(value) ) {
                if ( this._parent ) {
                    this.rotation = value - this._parent.worldRotation;
                }
                else {
                    this.rotation = value;
                }
            }
            else {
                Fire.error(ERR_NaN, 'new worldRotation');
            }
        }
    });

    /**
     * The local scale factor relative to the parent
     * @property scale
     * @type {Vec2}
     * @default new Vec2(1, 1)
     */
    Transform.getset('scale',
        function () {
            return new Vec2(this._scale.x, this._scale.y);
        },
        function (value) {
            var x = value.x;
            var y = value.y;
            if ( !isNaN(x) && !isNaN(y) ) {
                this._scale.x = x;
                this._scale.y = y;
            }
            else {
                Fire.error(ERR_NaN, 'xy of new scale');
            }
        },
        Fire.Tooltip('The local scale factor relative to the parent')
    );

    /**
     * The local x scale factor relative to the parent
     * @property scaleX
     * @type {number}
     * @default 1
     */
    Object.defineProperty(Transform.prototype, 'scaleX', {
        get: function () {
            return this._scale.x;
        },
        set: function (value) {
            if ( !isNaN(value) ) {
                this._scale.x = value;
                // notify change
                this._scale = this._scale;
            }
            else {
                Fire.error(ERR_NaN, 'new scaleX');
            }
        }
    });

    /**
     * The local y scale factor relative to the parent
     * @property scaleY
     * @type {number}
     * @default 1
     */
    Object.defineProperty(Transform.prototype, 'scaleY', {
        get: function () {
            return this._scale.y;
        },
        set: function (value) {
            if ( !isNaN(value) ) {
                this._scale.y = value;
                // notify change
                this._scale = this._scale;
            }
            else {
                Fire.error(ERR_NaN, 'new scaleY');
            }
        }
    });

    /**
     * The lossy scale of the transform in world space (Read Only)
     * @property worldScale
     * @type {Vec2}
     * @default new Vec2(1, 1)
     * @readOnly
     */
    Object.defineProperty(Transform.prototype, 'worldScale', {
        get: function () {
            var l2w = this.getLocalToWorldMatrix();
            return l2w.getScale();
        }
    });

    // override functions

    Transform.prototype.onLoad = function () {
        this._parent = this.entity._parent && this.entity._parent.transform;
    };

    Transform.prototype.destroy = function () {
        Fire.error("Not allowed to destroy the transform. Please destroy the entity instead.");
    };

    // other functions

    Transform.prototype._updateTransform = function (parentMatrix) {
        //var mat = this._worldTransform;

        //var px = this._pivot.x;
        //var py = this._pivot.y;

        //var radians = this._rotation * 0.017453292519943295;
        //var sin = this._rotation === 0 ? 0 : Math.sin(radians);
        //var cos = this._rotation === 0 ? 1 : Math.cos(radians);

        //// get local
        //mat.a = this._scale.x * cos;
        //mat.b = this._scale.x * sin;   // 这里如果是pixi，b和c是反过来的
        //mat.c = this._scale.y * - sin;
        //mat.d = this._scale.y * cos;
        //mat.tx = this._position.x;
        //mat.ty = this._position.y;

        //// parent
        //var pa = parentMatrix.a;
        //var pb = parentMatrix.b;
        //var pc = parentMatrix.c;
        //var pd = parentMatrix.d;

        //// local x parent
        //if (pa !== 1 || pb !== 0 || pc !== 0 || pd !== 1) {
        //    mat.a = mat.a * pa + mat.b * pc;
        //    mat.b = mat.a * pb + mat.b * pd;
        //    mat.c = mat.c * pa + mat.d * pc;
        //    mat.d = mat.c * pb + mat.d * pd;
        //    mat.tx = mat.tx * pa + mat.ty * pc + parentMatrix.tx;
        //    mat.ty = mat.tx * pb + mat.ty * pd + parentMatrix.ty;
        //}
        //else {
        //    mat.tx += parentMatrix.tx;
        //    mat.ty += parentMatrix.ty;
        //}

        var mat = this._worldTransform;
        this.getLocalMatrix(mat);
        mat.prepend(parentMatrix);

        //this._worldAlpha = this._alpha * this._parent._worldAlpha;

        // update children
        var children = this.entity._children;
        for (var i = 0, len = children.length; i < len; i++) {
            children[i].transform._updateTransform(mat);
        }
    };

    Transform.prototype._updateRootTransform = function () {
        var mat = this._worldTransform;
        this.getLocalMatrix(mat);
        //this._worldAlpha = this._alpha;

        // update children
        var children = this.entity._children;
        for (var i = 0, len = children.length; i < len; i++) {
            children[i].transform._updateTransform(mat);
        }
    };

    /**
     * Get the local matrix that transforms a point from local space into parents space.
     * @method getLocalMatrix
     * @param {Matrix23} [out] - optional, the receiving vector
     * @return {Matrix23}
     */
    Transform.prototype.getLocalMatrix = function (out) {
        out = out || new Matrix23();

        //var px = this._pivot.x;
        //var py = this._pivot.y;

        var radians = this._rotation * 0.017453292519943295;
        var sin = this._rotation === 0 ? 0 : Math.sin(radians);
        var cos = this._rotation === 0 ? 1 : Math.cos(radians);

        out.a = this._scale.x * cos;   // scaleMat.a * rotateMat.a(cos) 00
        // 这里如果是pixi，b和c是反过来的
        out.b = this._scale.x * sin;   // scaleMat.a * rotateMat.b(sin)
        out.c = this._scale.y * - sin; // scaleMat.d * rotateMat.c(-sin)
        //
        out.d = this._scale.y * cos;   // scaleMat.d * rotateMat.d(cos) 11
        out.tx = this._position.x;/* * ra + this._position.y * rc*/
        out.ty = this._position.y;/* * rb + this._position.y * rd*/
        //out.tx = this._position.x/* - out.a * px - py * out.b*/;    // 02
        //out.ty = this._position.y/* - out.d * py - px * out.c*/;    // 12

        //above should equivalent to:
        //  var t = new Matrix23();
        //  t.tx = this._position.x;
        //  t.ty = this._position.y;
        //  var r = new Matrix23();
        //  r.rotate(radians);
        //  var s = new Matrix23();
        //  s.setScale(this._scale);
        //  out.set(s.prepend(r).prepend(t));

        return out;
    };

    /**
     * Get the world transform matrix that transforms a point from local space into world space.
     * @method getLocalToWorldMatrix
     * @param {Matrix23} [out] - optional, the receiving vector
     * @return {Matrix23}
     */
    Transform.prototype.getLocalToWorldMatrix = function (out) {
        // todo, merge with this._worldTransform
        out = out || new Matrix23();
        this.getLocalMatrix(out);
        var t = new Fire.Matrix23();
        for (var p = this._parent; p !== null; p = p._parent) {
            out.prepend(p.getLocalMatrix(t));
        }
        return out;
    };

    /**
     * Get the inverse world transform matrix that transforms a point from world space into local space.
     * @method getWorldToLocalMatrix
     * @param {Matrix23} [out] - optional, the receiving vector
     * @return {Matrix23}
     */
    Transform.prototype.getWorldToLocalMatrix = function (out) {
        return this.getLocalToWorldMatrix(out).invert();
    };

    /**
     * Rotates this transform through point in world space by angle degrees.
     * @method rotateAround
     * @param {Vec2} point - the world point rotates through
     * @param {number} angle - degrees
     */
    Transform.prototype.rotateAround = function (point, angle) {
        var delta = this.worldPosition.subSelf(point);
        delta.rotateSelf(Math.deg2rad(angle));
        this.worldPosition = point.addSelf(delta);
        this.rotation = this._rotation + angle;
    };

    /**
     * Moves the transform in the direction and distance of translation. The movement is applied relative to the transform's local space.
     * @method translate
     * @param {Vec2} translation
     */
    Transform.prototype.translate = function (translation) {
        var rotated = translation.rotate(Math.deg2rad(this._rotation));
        this.position = this._position.add(rotated, rotated);
    };

    /**
     * up direction in world space, point to the y(green) axis
     * @property up
     * @type {Vec2}
     */
    Object.defineProperty(Transform.prototype, 'up', {
        get: function () {
            return (new Vec2(0.0, 1.0)).rotateSelf(Math.deg2rad(this.worldRotation));
        },
        set: function (value) {
            if (value.x === 0.0 && value.y === 0.0) {
                Fire.warn("Can't get rotation from zero vector");
                return;
            }
            var radians = Math.atan2(value.y, value.x) - Math.HALF_PI;
            this.worldRotation = Math.rad2deg(radians);
        }
    });

    /**
     * right direction in world space, point to the x(red) axis
     * @property right
     * @type {Vec2}
     */
    Object.defineProperty(Transform.prototype, 'right', {
        get: function () {
            return (new Vec2(1.0, 0.0)).rotateSelf(Math.deg2rad(this.worldRotation));
        },
        set: function (value) {
            if (value.x === 0.0 && value.y === 0.0) {
                Fire.warn("Can't get rotation from zero vector");
                return;
            }
            var radians = Math.atan2(value.y, value.x);
            this.worldRotation = Math.rad2deg(radians);
        }
    });

    ///**
    // * Subscribe the `onHierarchyChanged` event.
    // * When this transform or one of its parents' hierarchy changed, the `onHierarchyChanged`
    // * method will be invoked on supplied instance of Component. If you want to unsubscribe this event,
    // * you must destroy the Component.
    // * 这里不支持自定义回调，因为如果忘了反注册很容易就会内存泄漏。
    // *
    // * @method Fire.Transform#_addListener
    // * @param {Component} component - the component to be invoked.
    // * @private
    // */
    //Transform.prototype._addListener = function (component) {
    //    //if (component.entity === this.entity) {
    //        if (this._hierarchyChangedListeners) {
    //            this._hierarchyChangedListeners.push(component);
    //        }
    //        else {
    //            this._hierarchyChangedListeners = [component];
    //        }
    //    //}
    //    //else {
    //    //    Fire.error("Can not listen other entity's onHierarchyChanged event");
    //    //}
    //};

    //// 这里就算不调用，内存也不会泄露，因为component本身就会被destroy。
    //// 只不过调用了以后内存能清理的更及时。
    //Transform.prototype._removeListener = function (component) {
    //    if (this._hierarchyChangedListeners) {
    //        var idx = this._hierarchyChangedListeners.indexOf(component);
    //        this._hierarchyChangedListeners.splice(idx, 1);
    //    }
    //};

    //Transform.prototype._onHierarchyChanged = function (transform, oldParent) {
    //    // notify self listener
    //    if (this._hierarchyChangedListeners) {
    //        for (var i = this._hierarchyChangedListeners.length - 1; i >= 0; --i) {
    //            var target = this._hierarchyChangedListeners[i];
    //            if (target.isValid) {
    //                if (target.onHierarchyChanged(transform, oldParent)) {
    //                    // 目前只有一种component会终止事件，如果有多种，这里需要做分类
    //                    return;
    //                }
    //            }
    //            else {
    //                this._hierarchyChangedListeners.splice(i, 1);
    //            }
    //        }
    //    }
    //    // notify children
    //    for (var c = 0, len = this._children.length; c < len; c++) {
    //        this._children[c]._onHierarchyChanged(transform, oldParent);
    //    }
    //};

    return Transform;
})();

Fire.Transform = Transform;

var Renderer = (function () {

    /**
     * The base for all renderer
     * @class Renderer
     * @extends HashObject
     * @constructor
     */
    var Renderer = Fire.extend('Fire.Renderer', Component);

    ///**
    // * Returns a "local" axis aligned bounding box(AABB) of the renderer.
    // * The returned box is relative only to its parent.
    // *
    // * @function Fire.Renderer#getLocalBounds
    // * @param {Rect} [out] - optional, the receiving rect
    // * @return {Rect}
    // */
    //Renderer.prototype.getLocalBounds = function (out) {
    //    Fire.warn('interface not yet implemented');
    //    return new Fire.Rect();
    //};

    var tempMatrix = new Fire.Matrix23();

    /**
     * Returns a "world" axis aligned bounding box(AABB) of the renderer.
     *
     * @method getWorldBounds
     * @param {Rect} [out] - optional, the receiving rect
     * @return {Rect} - the rect represented in world position
     */
    Renderer.prototype.getWorldBounds = function (out) {
        var worldMatrix = this.entity.transform.getLocalToWorldMatrix();
        var bl = new Vec2(0, 0);
        var tl = new Vec2(0, 0);
        var tr = new Vec2(0, 0);
        var br = new Vec2(0, 0);
        _doGetOrientedBounds.call(this, worldMatrix, bl, tl, tr, br);
        out = out || new Rect();
        Math.calculateMaxRect(out, bl, tl, tr, br);
        return out;
    };

    /**
     * Returns a "world" oriented bounding box(OBB) of the renderer.
     *
     * @method getWorldOrientedBounds
     * @param {Vec2} [out_bl] - optional, the vector to receive the world position of bottom left
     * @param {Vec2} [out_tl] - optional, the vector to receive the world position of top left
     * @param {Vec2} [out_tr] - optional, the vector to receive the world position of top right
     * @param {Vec2} [out_br] - optional, the vector to receive the world position of bottom right
     * @return {Vec2} - the array contains vectors represented in world position,
     *                    in the sequence of BottomLeft, TopLeft, TopRight, BottomRight
     */
    Renderer.prototype.getWorldOrientedBounds = function (out_bl, out_tl, out_tr, out_br){
        out_bl = out_bl || new Vec2(0, 0);
        out_tl = out_tl || new Vec2(0, 0);
        out_tr = out_tr || new Vec2(0, 0);
        out_br = out_br || new Vec2(0, 0);
        var worldMatrix = this.entity.transform.getLocalToWorldMatrix();
        _doGetOrientedBounds.call(this, worldMatrix, out_bl, out_tl, out_tr, out_br);
        return [out_bl, out_tl, out_tr, out_br];
    };

    /**
     * !#zh 返回表示 renderer 的 width/height/pivot/skew/shear 等变换的 matrix，
     * 这些变换不影响子物体，getLocalToWorldMatrix 返回的变换会影响子物体。
     *
     * @method getSelfMatrix
     * @param {Matrix23} out - the receiving matrix
     */
    Renderer.prototype.getSelfMatrix = function (out) {
    };

    /**
     * @method getWorldSize
     * @return {Vec2}
     */
    Renderer.prototype.getWorldSize = function () {
        return new Vec2(0, 0);
    };

    function _doGetOrientedBounds(mat, bl, tl, tr, br) {
        var size = this.getWorldSize();
        var width = size.x;
        var height = size.y;

        this.getSelfMatrix(tempMatrix);
        mat = tempMatrix.prepend(mat);

        // transform rect(0, 0, width, height) by matrix
        var tx = mat.tx;
        var ty = mat.ty;
        var xa = mat.a * width;
        var xb = mat.b * width;
        var yc = mat.c * -height;
        var yd = mat.d * -height;

        tl.x = tx;
        tl.y = ty;
        tr.x = xa + tx;
        tr.y = xb + ty;
        bl.x = yc + tx;
        bl.y = yd + ty;
        br.x = xa + yc + tx;
        br.y = xb + yd + ty;
    }

    return Renderer;
})();

Fire.Renderer = Renderer;

var SpriteRenderer = (function () {

    /**
     * Renders a sprite in the scene.
     * @class SpriteRenderer
     * @extends Renderer
     * @constructor
     */
    var SpriteRenderer = Fire.extend('Fire.SpriteRenderer', Renderer, function () {
        RenderContext.initRenderer(this);
        this._hasRenderObj = false;
    });
    Fire.addComponentMenu(SpriteRenderer, 'SpriteRenderer');
    Fire.executeInEditMode(SpriteRenderer);

    SpriteRenderer.prop('_sprite', null, Fire.HideInInspector);
    /**
     * The sprite to render.
     * @property sprite
     * @type {Sprite}
     * @default null
     */
    SpriteRenderer.getset('sprite',
        function () {
            return this._sprite;
        },
        function (value) {
            this._sprite = value;
            if (this._hasRenderObj) {
                Engine._renderContext.updateMaterial(this);
            }
        },
        Fire.ObjectType(Fire.Sprite)
    );

    SpriteRenderer.prop('_color', new Fire.Color(1, 1, 1, 1), Fire.HideInInspector);
    /**
     * !#en The rendering color.
     * !#zh Sprite 渲染的颜色，其中 alpha 为 1 时表示不透明，0.5 表示半透明，0 则全透明。
     * @property color
     * @type Color
     * @default new Color(1, 1, 1, 1)
     */
    SpriteRenderer.getset('color',
        function () {
            return this._color;
        },
        function (value) {
            this._color = value;
            if (this._hasRenderObj) {
                Engine._renderContext.updateSpriteColor(this);
            }
        }
    );

    SpriteRenderer.prop('customSize_', false, Fire.HideInInspector);

    /**
     * !#en Indicates that this renderer uses custom width and height to render the sprite.
     * !#zh 是否使用自定义尺寸渲染。
     * - 为 true 时将忽略 sprite 的大小，使用 renderer 的 width 和 height 进行渲染。
     * - 为 false 则使用 sprite 原有的 width 和 height 进行渲染。
     *
     * @property customSize
     * @type {boolean}
     * @default false
     */
    SpriteRenderer.getset('customSize',
        function () {
            return this.customSize_;
        },
        function (value) {
            this.customSize_ = value;
        }
    );

    SpriteRenderer.prop('width_', 100, Fire.DisplayName('Width'),
                        Fire.Watch( 'customSize_', function ( obj, propEL ) {
                            propEL.disabled = !obj.customSize_;
                        } ));
    /**
     * !#en The custom width of this renderer.
     * !#zh 获取该 Renderer 的渲染宽度，如果使用的是 customSize，获取到的是 custom width，否则是 sprite width。
     * 设置这个值时，会修改 custom width。
     * @property width
     * @type {number}
     * @beta
     */
    SpriteRenderer.getset('width',
        function () {
            if ( !this.customSize_ ) {
                return Fire.isValid(this._sprite) ? this._sprite.width : 0;
            }
            else {
                return this.width_;
            }
        },
        function (value) {
            this.width_ = value;
        },
        Fire.HideInInspector
    );

    SpriteRenderer.prop('height_', 100, Fire.DisplayName('Height'),
                        Fire.Watch( 'customSize_', function ( obj, propEL) {
                            propEL.disabled = !obj.customSize;
                        } ));

    /**
     * !#en The custom height of this renderer.
     * !#zh 获取该 Renderer 的渲染高度，如果使用的是 customSize，获取到的是 custom height，否则是 sprite height。
     * 设置这个值时，会修改 custom height。
     * @property height
     * @type {number}
     * @beta
     */
    SpriteRenderer.getset('height',
        function () {
            if ( !this.customSize_ ) {
                return Fire.isValid(this._sprite) ? this._sprite.height : 0;
            }
            else {
                return this.height_;
            }
        },
        function (value) {
            this.height_ = value;
        },
        Fire.HideInInspector
    );

    // built-in functions

    SpriteRenderer.prototype.onLoad = function () {
        Engine._renderContext.addSprite(this);
        this._hasRenderObj = true;
    };
    SpriteRenderer.prototype.onEnable = function () {
        Engine._renderContext.show(this, true);
    };
    SpriteRenderer.prototype.onDisable = function () {
        Engine._renderContext.show(this, false);
    };

    SpriteRenderer.prototype.getWorldSize = function () {
        return new Fire.Vec2(this.width, this.height);
    };

    var tempMatrix = new Fire.Matrix23();

    SpriteRenderer.prototype.onPreRender = function () {
        this.getSelfMatrix(tempMatrix);
        if (this._sprite) {
            // calculate render matrix
            //   scale
            tempMatrix.a = this.width / this._sprite.width;
            tempMatrix.d = this.height / this._sprite.height;
            //   rotate cw
            if (this._sprite.rotated) {
                tempMatrix.b = tempMatrix.d;
                tempMatrix.c = -tempMatrix.a;
                tempMatrix.a = 0;
                tempMatrix.d = 0;
                tempMatrix.ty -= this.height;
            }
        }
        tempMatrix.prepend(this.transform._worldTransform);
        Engine._curRenderContext.updateTransform(this, tempMatrix);
    };
    SpriteRenderer.prototype.onDestroy = function () {
        Engine._renderContext.remove(this);
    };

    SpriteRenderer.prototype.getSelfMatrix = function (out) {
        var w = this.width;
        var h = this.height;

        var pivotX = 0.5;
        var pivotY = 0.5;

        //var rotated = false;
        if (Fire.isValid(this._sprite)) {
            //rotated = this._sprite.rotated;
            pivotX = this._sprite.pivot.x;
            pivotY = this._sprite.pivot.y;
        }

        //if ( !rotated ) {
            out.a = 1;
            out.b = 0;
            out.c = 0;
            out.d = 1;
            out.tx = - pivotX * w;
            out.ty = (1.0 - pivotY) * h;
        //}
        //else {
        //    // CCW
        //    //out.a = 0;
        //    //out.b = scaleY;
        //    //out.c = -scaleX;
        //    //out.d = 0;
        //    //out.tx = - (pivotY - 1.0) * w;
        //    //out.ty = - pivotX * h;
        //
        //    // CW
        //    out.a = 0;
        //    out.b = -scaleY;
        //    out.c = scaleX;
        //    out.d = 0;
        //    out.tx = (1.0 - pivotX) * w;
        //    out.ty = (1.0 - pivotY) * h;
        //}
    };

    return SpriteRenderer;
})();

Fire.SpriteRenderer = SpriteRenderer;


var BitmapText = (function () {

    /**
     * The bitmap font renderer component.
     * @class BitmapText
     * @extends Renderer
     * @constructor
     */
    var BitmapText = Fire.extend("Fire.BitmapText", Renderer, function () {
        RenderContext.initRenderer(this);
    });

    //-- 增加 Bitmap Text 到 组件菜单上
    Fire.addComponentMenu(BitmapText, 'BitmapText');
    Fire.executeInEditMode(BitmapText);

    BitmapText.prop('_bitmapFont', null, Fire.HideInInspector);
    /**
     * The font to render.
     * @property bitmapFont
     * @type {BitmapFont}
     * @default null
     */
    BitmapText.getset('bitmapFont',
        function () {
            return this._bitmapFont;
        },
        function (value) {
            this._bitmapFont = value;
            Engine._renderContext.updateBitmapFont(this);
        },
        Fire.ObjectType(Fire.BitmapFont)
    );

    BitmapText.prop('_text', 'Text', Fire.HideInInspector);

    /**
     * The text to render.
     * @property text
     * @type {string}
     * @default ""
     */
    BitmapText.getset('text',
        function () {
            return this._text;
        },
        function (value) {
            if (this._text !== value) {
                if (typeof value === 'string') {
                    this._text = value;
                }
                else {
                    this._text = '' + value;
                }
                Engine._renderContext.setText(this, this._text);
            }
        },
        Fire.MultiText
    );

    BitmapText.prop('_anchor', Fire.TextAnchor.midCenter, Fire.HideInInspector);

    /**
     * The anchor point of the text.
     * @property anchor
     * @type {BitmapText.TextAnchor}
     * @default BitmapText.TextAnchor.midCenter
     */
    BitmapText.getset('anchor',
        function () {
            return this._anchor;
        },
        function (value) {
            if (this._anchor !== value) {
                this._anchor = value;
            }
        },
        Fire.Enum(Fire.TextAnchor)
    );

    BitmapText.prop('_align', Fire.TextAlign.left, Fire.HideInInspector);

    /**
     * How lines of text are aligned (left, right, center).
     * @property align
     * @type {BitmapText.TextAlign}
     * @default BitmapText.TextAlign.left
     */
    BitmapText.getset('align',
        function () {
            return this._align;
        },
        function (value) {
            if (this._align !== value) {
                this._align = value;
                Engine._renderContext.setAlign(this, value);
            }
        },
        Fire.Enum(Fire.TextAlign)
    );

    BitmapText.prototype.onLoad = function () {
        Engine._renderContext.addBitmapText(this);
    };

    BitmapText.prototype.onEnable = function () {
        Engine._renderContext.show(this, true);
    };

    BitmapText.prototype.onDisable = function () {
        Engine._renderContext.show(this, false);
    };

    BitmapText.prototype.onDestroy = function () {
        Engine._renderContext.remove(this);
    };

    BitmapText.prototype.getWorldSize = function () {
        return Engine._renderContext.getTextSize(this);
    };

    var tempMatrix = new Fire.Matrix23();

    BitmapText.prototype.onPreRender = function () {
        this.getSelfMatrix(tempMatrix);
        tempMatrix.prepend(this.transform._worldTransform);
        RenderContext.updateBitmapTextTransform(this, tempMatrix);
    };

    BitmapText.prototype.getSelfMatrix = function (out) {
        var textSize = Engine._renderContext.getTextSize(this);
        var w = textSize.x;
        var h = textSize.y;

        var anchorOffsetX = 0;
        var anchorOffsetY = 0;

        switch (this._anchor) {
            case Fire.TextAnchor.topLeft:
                break;
            case Fire.TextAnchor.topCenter:
                anchorOffsetX = w * -0.5;
                break;
            case Fire.TextAnchor.topRight:
                anchorOffsetX = -w;
                break;
            case Fire.TextAnchor.midLeft:
                anchorOffsetY = h * 0.5;
                break;
            case Fire.TextAnchor.midCenter:
                anchorOffsetX = w * -0.5;
                anchorOffsetY = h * 0.5;
                break;
            case Fire.TextAnchor.midRight:
                anchorOffsetX = -w;
                anchorOffsetY = h * 0.5;
                break;
            case Fire.TextAnchor.botLeft:
                anchorOffsetY = h;
                break;
            case Fire.TextAnchor.botCenter:
                anchorOffsetX = w * -0.5;
                anchorOffsetY = h;
                break;
            case Fire.TextAnchor.botRight:
                anchorOffsetX = -w;
                anchorOffsetY = h;
                break;
            default:
                break;
        }
        out.a = 1;
        out.b = 0;
        out.c = 0;
        out.d = 1;
        out.tx = anchorOffsetX;
        out.ty = anchorOffsetY;
    };

    return BitmapText;
})();

Fire.BitmapText = BitmapText;

var Text = (function () {
    /**
     * @class FontType
     * @static
     */
    var FontType = Fire.defineEnum({
        /**
         * @property Arial
         * @type {number}
         */
        Arial: -1,
        /**
         * @property Custom
         * @type {number}
         */
        Custom: -1
    });

    var tempMatrix = new Fire.Matrix23();

    var Text = Fire.Class({
        // 名字
        name: "Fire.Text",
        // 继承
        extends: Renderer,
        // 构造函数
        constructor: function () {
            RenderContext.initRenderer(this);
        },
        // 属性
        properties: {
            // 字体类型
            _fontType: {
                default: FontType.Arial,
                type: FontType
            },
            fontType: {
                get: function () {
                    return this._fontType;
                },
                set: function (value) {
                    this._fontType = value;
                    Engine._renderContext.setTextStyle(this);
                },
                type: FontType
            },
            _customFontType: "Arial",
            customFontType:{
                get: function () {
                    return this._customFontType;
                },
                set: function (value) {
                    this._customFontType = value;
                    Engine._renderContext.setTextStyle(this);
                },
                watch: {
                    '_fontType': function (obj, propEL) {
                        propEL.disabled = obj._fontType !== FontType.Custom;
                    }
                }
            },
            // 文字内容
            _text: 'text',
            //
            text: {
                get: function () {
                    return this._text;
                },
                set: function (value) {
                    this._text = value;
                    Engine._renderContext.setTextContent(this, this._text);
                },
                multiline: true
            },
            // 字体大小
            _size: 30,
            size: {
                get: function() {
                    return this._size;
                },
                set: function(value) {
                    if (value !== this._size && value > 0) {
                        this._size = value;
                        Engine._renderContext.setTextStyle(this);
                    }
                }
            },
            // 字体颜色
            _color: Fire.Color.white,
            color: {
                get: function() {
                    return this._color;
                },
                set: function(value) {
                    this._color = value;
                    Engine._renderContext.setTextStyle(this);
                }
            },
            // 字体对齐方式
            _align: Fire.TextAlign.left,
            align: {
                get: function() {
                    return this._align;
                },
                set: function(value) {
                    this._align = value;
                    Engine._renderContext.setTextStyle(this);
                },
                type: Fire.TextAlign
            },
            // 字体锚点
            _anchor: Fire.TextAnchor.midCenter,
            anchor: {
                get: function() {
                    return this._anchor;
                },
                set: function(value){
                    if (value !== this._anchor) {
                        this._anchor = value;
                    }
                },
                type: Fire.TextAnchor
            }
        },
        onLoad: function () {
            Engine._renderContext.addText(this);
        },
        onEnable: function () {
            Engine._renderContext.show(this, true);
        },
        onDisable: function () {
            Engine._renderContext.show(this, false);
        },
        onDestroy: function () {
            Engine._renderContext.remove(this);
        },
        getWorldSize: function () {
            return Engine._renderContext.getTextSize(this);
        },
        getSelfMatrix: function (out) {
            var textSize = Engine._renderContext.getTextSize(this);
            var w = textSize.x;
            var h = textSize.y;

            var anchorOffsetX = 0;
            var anchorOffsetY = 0;

            switch (this._anchor) {
                case Fire.TextAnchor.topLeft:
                    break;
                case Fire.TextAnchor.topCenter:
                    anchorOffsetX = w * -0.5;
                    break;
                case Fire.TextAnchor.topRight:
                    anchorOffsetX = -w;
                    break;
                case Fire.TextAnchor.midLeft:
                    anchorOffsetY = h * 0.5;
                    break;
                case Fire.TextAnchor.midCenter:
                    anchorOffsetX = w * -0.5;
                    anchorOffsetY = h * 0.5;
                    break;
                case Fire.TextAnchor.midRight:
                    anchorOffsetX = -w;
                    anchorOffsetY = h * 0.5;
                    break;
                case Fire.TextAnchor.botLeft:
                    anchorOffsetY = h;
                    break;
                case Fire.TextAnchor.botCenter:
                    anchorOffsetX = w * -0.5;
                    anchorOffsetY = h;
                    break;
                case Fire.TextAnchor.botRight:
                    anchorOffsetX = -w;
                    anchorOffsetY = h;
                    break;
                default:
                    break;
            }
            out.a = 1;
            out.b = 0;
            out.c = 0;
            out.d = 1;
            out.tx = anchorOffsetX;
            out.ty = anchorOffsetY;
        },
        onPreRender: function () {
            this.getSelfMatrix(tempMatrix);
            tempMatrix.prepend(this.transform._worldTransform);
            RenderContext.updateTextTransform(this, tempMatrix);
        }
    });

    Text.FontType = FontType;

    //-- 增加 Text 到 组件菜单上
    Fire.addComponentMenu(Text, 'Text');
    Fire.executeInEditMode(Text);

    return Text;
})();

Fire.Text = Text;

/**
 * @class Camera
 * @extends Component
 * @constructor
 */
var Camera = Fire.Class({
    name: 'Fire.Camera',
    extends: Component,
    constructor: function () {
        this._renderContext = null;
        this._contentStrategyInst = null;
    },

    properties: {

        _background: Fire.Color.black,

        /**
         * The color of the screen background.
         * @property background
         * @type {Color}
         * @default Fire.Color.black
         */
        background: {
            get: function () {
                return this._background;
            },
            set: function (value) {
                this._background = value;
                if (this._renderContext) {
                    this._renderContext.background = value;
                }
            }
        },

        _size: 800,

        /**
         * The height of Design Resolution in pixels
         * @property size
         * @type {number}
         * @default 800
         * @beta
         */
        size: {
            get: function () {
                return this._size;
            },
            set: function (value) {
                this._size = value;
            },
            tooltip: "The height of design resolution. Width varies depending on viewport's aspect ratio",
            watch: {
                '_contentStrategy': function (obj, propEL) {
                    propEL.disabled = (obj._contentStrategy === Fire.ContentStrategyType.NoScale);
                }
            }
        },

        _contentStrategy: Fire.ContentStrategyType.FixedHeight,

        /**
         * The Content Strategy of the camera.
         * @property contentStrategy
         * @type {ContentStrategyType}
         * @default Fire.ContentStrategyType.FixedHeight
         */
        contentStrategy: {
            type: Fire.ContentStrategyType,
            get: function () {
                return this._contentStrategy;
            },
            set: function (value) {
                this._contentStrategy = value;
                this._contentStrategyInst = Fire.Screen.ContentStrategy.fromType(value);
            },
            displayName: 'Scale Strategy',
            tooltip: "The type of scale strategy for this camera"
        },

        /**
         * @property viewportInfo
         * @type {object}
         * @private
         */
        viewportInfo: {
            get: function (value) {
                var viewportSize = (this._renderContext || Engine._renderContext).size;
                return this._contentStrategyInst.apply(new Vec2(0, this._size), viewportSize);
            },
            visible: false
        },

        /**
         * save the render context this camera belongs to, if null, main render context will be used.
         * @property renderContext
         * @type {_Runtime.RenderContext}
         * @private
         */
        renderContext: {
            set: function (value) {
                this._renderContext = value;
                //                //if ( !Engine.isPlaying ) {
                //    this.size = value.size.y;
                //}
                //                this._applyRenderSettings();
            },
            visible: false
        }
    },

    // built-in functions
    onLoad: function () {
        if (!(this.entity._objFlags & HideInGame)) {
            this.renderContext = Engine._renderContext;
        }
        this._contentStrategyInst = Fire.Screen.ContentStrategy.fromType(this._contentStrategy);
    },
    onEnable: function () {
        if (!(this.entity._objFlags & HideInGame)) {
            Engine._scene.camera = this;
            this._applyRenderSettings();
        }
    },
    onDisable: function () {
        if (Engine._scene.camera === this) {
            Engine._scene.camera = null;
        }
        if (this._renderContext) {
            this._renderContext.camera = null;
        }
    },

    // other functions

    /**
     * Transforms position from viewport space into screen space.
     * @method viewportToScreen
     * @param {Vec2} position
     * @param {Vec2} [out] - optional, the receiving vector
     * @return {Vec2}
     */
    viewportToScreen: function (position, out) {
        if ( !this._renderContext ) {
            Fire.error("Camera not yet inited.");
            return;
        }
        out = this._renderContext.size.scale(position, out);
        return out;
    },

    /**
     * Transforms position from screen space into viewport space.
     * @method screenToViewport
     * @param {Vec2} position
     * @param {Vec2} [out] - optional, the receiving vector
     * @return {Vec2}
     */
    screenToViewport: function (position, out) {
        out = out || new Vec2();
        if ( !this._renderContext ) {
            Fire.error("Camera not yet inited.");
            return;
        }
        var size = this._renderContext.size;
        out.x = position.x / size.x;
        out.y = position.y / size.y;
        return out;
    },

    /**
     * Transforms position from viewport space into world space.
     * @method viewportToWorld
     * @param {Vec2} position
     * @param {Vec2} [out] - optional, the receiving vector
     * @return {Vec2}
     */
    viewportToWorld: function (position, out) {
        out = this.viewportToScreen(position, out);
        return this.screenToWorld(out, out);
    },

    /**
     * Transforms position from screen space into world space.
     * @method screenToWorld
     * @param {Vec2} position
     * @param {Vec2} [out] - optional, the receiving vector
     * @return {Vec2}
     */
    screenToWorld: function (position, out) {
        var halfScreenSize = (this._renderContext || Engine._renderContext).size.mul(0.5);
        var pivotToScreen = position.sub(halfScreenSize, halfScreenSize);
        pivotToScreen.y = -pivotToScreen.y; // 屏幕坐标的Y和世界坐标的Y朝向是相反的
        var mat = new Matrix23();
        var camPos = new Vec2();
        this._calculateTransform(mat, camPos);
        mat.invert();
        mat.tx = camPos.x;
        mat.ty = camPos.y;
        return mat.transformPoint(pivotToScreen, out);
    },

    /**
     * Transforms position from world space into screen space.
     * @method worldToScreen
     * @param {Vec2} position
     * @param {Vec2} [out] - optional, the receiving vector
     * @return {Vec2}
     */
    worldToScreen: function (position, out) {
        var mat = new Matrix23();
        var camPos = new Vec2();
        this._calculateTransform(mat, camPos);
        var toCamera = position.sub(camPos, camPos);
        out = mat.transformPoint(toCamera, out);
        var height = (this._renderContext || Engine._renderContext).size.y;
        out.y = height - out.y;
        return out;
    },

    /**
     * Transforms position from world space into viewport space.
     * @method worldToViewport
     * @param {Vec2} position
     * @param {Vec2} [out] - optional, the receiving vector
     * @return {Vec2}
     */
    worldToViewport: function (position, out) {
        out = this.worldToScreen(position, out);
        return this.screenToViewport(out, out);
    },

    _calculateTransform: function (out_matrix, out_worldPos) {
        var viewportInfo = this.viewportInfo;
        var scale = viewportInfo.scale;
        var viewport = viewportInfo.viewport;

        var tf = this.entity.transform;
        var mat = tf.getLocalToWorldMatrix();

        out_worldPos.x = mat.tx;
        out_worldPos.y = mat.ty;

        out_matrix.identity();
        out_matrix.tx = viewport.width * 0.5;
        out_matrix.ty = viewport.height * 0.5;
        out_matrix.a = scale.x;
        out_matrix.d = scale.y;
        out_matrix.rotate(mat.getRotation());
    },

    _applyRenderSettings: function () {
        if (!this._renderContext) {
            Fire.error('No corresponding render context for camera ' + this.entity.name);
            return;
        }
        this._renderContext.background = this._background;
    }
});

Fire.addComponentMenu(Camera, 'Camera');
Fire.executeInEditMode(Camera);

//Object.defineProperty(Camera.prototype, 'scaleStrategyInst', {
//    get: function (value) {
//        if ( !this._cachedResolutionPolicy ) {
//            this._cachedResolutionPolicy = Fire.Screen.ResolutionPolicy.fromType(this._resolutionPolicy);
//        }
//        return this._cachedResolutionPolicy;
//    }
//});

Fire.Camera = Camera;


var MissingScript = (function () {

    /**
     * A temp fallback to contain the original component which can not be loaded.
     * Actually, this class will be used whenever a class failed to deserialize,
     * regardless of whether it is child class of component.
     */
    var MissingScript = Fire.extend('Fire.MissingScript', Component);

    MissingScript.prototype.onLoad = function () {
        Fire.warn('The referenced script on this Component is missing!');
    };

    return MissingScript;
})();

Fire._MissingScript = MissingScript;

/**
 * The InteractionContext contains all the entities which can be interact with.
 * @private
 */
var InteractionContext = (function () {

    var aabbMap = {};   // all axis aligned bounding boxes in current frame, indexed by id
    var obbMap = {};    // all oriented bounding boxes in current frame, indexed by id

    function InteractionContext () {
        this.entities = [];   // array of interactable entities in this context, sorted from back to front
    }

    InteractionContext.prototype._clear = function () {
        this.entities.length = 0;
    };

    /**
     * Pick the top most entity, using their oriented bounding boxes.
     * @param {Vec2} worldPosition
     * @return {Entity}
     */
    InteractionContext.prototype.pick = function (worldPosition) {
        for (var i = this.entities.length - 1; i >= 0; --i) {
            var entity = this.entities[i];
            if (entity.isValid) {
                // aabb test
                var aabb = aabbMap[entity.id];
                if (aabb.contains(worldPosition)) {
                    // obb test
                    var obb = obbMap[entity.id];
                    var polygon = new Fire.Polygon(obb);
                    if (polygon.contains(worldPosition)) {
                        return entity;
                    }
                }
            }
        }
        return null;
    };

    InteractionContext.prototype._updateRecursilvey = function (entity) {
        var renderer = entity.getComponent(Fire.Renderer);
        if (renderer && renderer._enabled) {
            this.entities.push(entity);
            var id = entity.id;
            if ( !obbMap[id] ) {
                var obb = renderer.getWorldOrientedBounds();
                var aabb = Math.calculateMaxRect(new Rect(), obb[0], obb[1], obb[2], obb[3]);
                obbMap[id] = obb;
                aabbMap[id] = aabb;
            }
        }

        for ( var i = 0, len = entity._children.length; i < len; ++i ) {
            var child = entity._children[i];
            if (child._active) {
                this._updateRecursilvey(child);
            }
        }
    };

    InteractionContext.prototype.update = function (entities) {
        // 目前还没有专门处理physics的模块，暂时hack一下
        var newFrame = !Engine.isPlaying || this === Engine._interactionContext;
        if (newFrame) {
            aabbMap = {};
            obbMap = {};
        }

        // clear intersection data
        this._clear();

        // recursively process each entity
        for (var i = 0, len = entities.length; i < len; ++i) {
            var entity = entities[i];
            if (entity._active) {
                this._updateRecursilvey(entity);
            }
        }
    };

    // entity 必须是 entities 里面的
    InteractionContext.prototype.getAABB = function (entity) {
        return aabbMap[entity.id];
    };

    // entity 必须是 entities 里面的
    InteractionContext.prototype.getOBB = function (entity) {
        return obbMap[entity.id];
    };

    return InteractionContext;
})();

Fire._InteractionContext = InteractionContext;

/**
 * Class of all entities in scenes.
 * @class Entity
 * @constructor
 * @param {string} name - the name of the entity
 */
var Entity = Fire.Class({

    name: 'Fire.Entity', extends: EventTarget,

    constructor: function () {
        var name = arguments[0];

        this._name = typeof name !== 'undefined' ? name : 'New Entity';
        this._objFlags |= Entity._defaultFlags;

        if (Fire._isCloning) {
            // create by deserializer or instantiating

            this._activeInHierarchy = false;
        }
        else {
            // create dynamically

            this._activeInHierarchy = true;
            // init transform
            var transform = new Transform();
            transform.entity = this;
            this._components = [transform];
            this.transform = transform;

            // add to scene
            if (Engine._scene) {
                Engine._scene.appendRoot(this);
            }

            if ( Engine._canModifyCurrentScene ) {
                // invoke callbacks
                Engine._renderContext.onRootEntityCreated(this);

                // activate componet
                transform._onEntityActivated(true);     // 因为是刚刚创建，所以 activeInHierarchy 肯定为 true

                if (editorCallback.onEntityCreated) {
                    editorCallback.onEntityCreated(this);
                }
                if (editorCallback.onComponentAdded) {
                    editorCallback.onComponentAdded(this, transform);
                }
            }
        }
    },

    properties: {

        name: {
            get: function () {
                return this._name;
            },
            set: function (value) {
                this._name = value;
                if (editorCallback.onEntityRenamed) {
                    editorCallback.onEntityRenamed(this);
                }
            }
        },

        /**
         * The local active state of this Entity.
         * @property active
         * @type {boolean}
         * @default true
         */
        active: {
            get: function () {
                return this._active;
            },
            set: function (value) {
                // jshint eqeqeq: false
                if (this._active != value) {
                    // jshint eqeqeq: true
                    this._active = value;
                    var canActiveInHierarchy = (!this._parent || this._parent._activeInHierarchy);
                    if (canActiveInHierarchy) {
                        this._onActivatedInHierarchy(value);
                    }
                }
            }
        },

        /**
         * Indicates whether this entity is active in the scene.
         * @property activeInHierarchy
         * @type {boolean}
         */
        activeInHierarchy: {
            get: function () {
                return this._activeInHierarchy;
            }
        },

        /**
         * Returns the {% crosslink Fire.Transform Transform %} attached to the entity.
         * @property transform
         * @type {Transform}
         * @readOnly
         */
        transform: {
            default: null,
            visible: false
        },

        /**
         * The parent of the entity.
         * Changing the parent will keep the transform's local space position, rotation and scale the same but modify the world space position, scale and rotation.
         * @property parent
         * @type {Entity}
         * @default null
         */
        parent: {
            get: function () {
                return this._parent;
            },
            set: function (value) {
                if (this._parent !== value) {
                    if (value === this) {
                        Fire.warn("A entity can't be set as the parent of itself.");
                        return;
                    }
                    if (value && !(value instanceof Entity)) {
                        if (value instanceof Transform) {
                            Fire.error('Entity.parent can not be a Transform, use transform.entity instead.');
                        }
                        else {
                            Fire.error('Entity.parent must be instance of Entity (or must be null)');
                        }
                        return;
                    }
                    var oldParent = this._parent;
                    if (value) {
                        if ((value._objFlags & HideInGame) && !(this._objFlags & HideInGame)) {
                            Fire.error('Failed to set parent, the child\'s HideInGame must equals to parent\'s.');
                            return;
                        }
                        if ((value._objFlags & HideInEditor) && !(this._objFlags & HideInEditor)) {
                            Fire.error('Failed to set parent, the child\'s HideInEditor must equals to parent\'s.');
                            return;
                        }
                        if (!oldParent) {
                            Engine._scene.removeRoot(this);
                        }
                        value._children.push(this);
                    }
                    else {
                        Engine._scene.appendRoot(this);
                    }
                    this._parent = value || null;
                    this.transform._parent = this._parent && this._parent.transform;

                    if (oldParent && !(oldParent._objFlags & Destroying)) {
                        oldParent._children.splice(oldParent._children.indexOf(this), 1);
                        this._onHierarchyChanged(oldParent);
                    }
                    Engine._renderContext.onEntityParentChanged(this, oldParent);
                    if (editorCallback.onEntityParentChanged) {
                        editorCallback.onEntityParentChanged(this);
                    }
                    //this._onHierarchyChanged(this, oldParent);
                }
            }
        },

        /**
         * Get the amount of children
         * @property childCount
         * @type {number}
         */
        childCount: {
            get: function () {
                return this._children.length;
            },
            visible: false
        },

        /**
         * If true, the entity will not be destroyed automatically when loading a new scene.
         * @property dontDestroyOnLoad
         * @type {boolean}
         * @default false
         */
        dontDestroyOnLoad: {
            get: function () {
                return !!(this._objFlags | DontDestroy);
            },
            set: function (value) {
                if (value) {
                    this._objFlags |= DontDestroy;
                }
                else {
                    this._objFlags &= ~DontDestroy;
                }
            }
        },

        // internal properties

        _active: true,
        _parent: null,

        /**
         * @property _children
         * @type {Entity[]}
         * @default []
         * @readOnly
         * @private
         */
        _children: [],

        /**
         * @property _components
         * @type {Component[]}
         * @default []
         * @readOnly
         * @private
         */
        _components: null
    },

    ////////////////////////////////////////////////////////////////////
    // overrides
    ////////////////////////////////////////////////////////////////////

    destroy: function () {
        if (FObject.prototype.destroy.call(this)) {
            // disable hierarchy
            if (this._activeInHierarchy) {
                this._deactivateChildComponents();
            }
        }
    },

    _onPreDestroy: function () {
        var parent = this._parent;
        this._objFlags |= Destroying;
        var isTopMost = !(parent && (parent._objFlags & Destroying));
        if (isTopMost) {
            Engine._renderContext.onEntityRemoved(this);
            if (editorCallback.onEntityRemoved) {
                editorCallback.onEntityRemoved(this/*, isTopMost*/);
            }
        }
        // destroy components
        for (var c = 0; c < this._components.length; ++c) {
            var component = this._components[c];
            // destroy immediate so its _onPreDestroy can be called before
            component._destroyImmediate();
        }
        // remove self
        if (parent) {
            if (isTopMost) {
                parent._children.splice(parent._children.indexOf(this), 1);
            }
        }
        else {
            Engine._scene.removeRoot(this);
        }
        // destroy children
        var children = this._children;
        for (var i = 0, len = children.length; i < len; ++i) {
            // destroy immediate so its _onPreDestroy can be called before
            children[i]._destroyImmediate();
        }
    },

    _getCapturingTargets: function (type, array) {
        for (var target = this._parent; target; target = target._parent) {
            if (target._activeInHierarchy && target._capturingListeners && target._capturingListeners.has(type)) {
                array.push(target);
            }
        }
    },

    _getBubblingTargets: function (type, array) {
        for (var target = this._parent; target; target = target._parent) {
            if (target._activeInHierarchy && target._bubblingListeners && target._bubblingListeners.has(type)) {
                array.push(target);
            }
        }
    },

    _doSendEvent: function (event) {
        if (this._activeInHierarchy) {
            Entity.$super.prototype._doSendEvent.call(this, event);
        }
    },

    ////////////////////////////////////////////////////////////////////
    // component methods
    ////////////////////////////////////////////////////////////////////

    /**
     * Adds a component class to the entity. You can also add component to entity by passing in the name of the script.
     *
     * @method addComponent
     * @param {function|string} typeOrName - the constructor or the class name of the component to add
     * @return {Component} - the newly added component
     */
    addComponent: function (typeOrTypename) {
        var constructor;
        if (typeof typeOrTypename === 'string') {
            constructor = JS.getClassByName(typeOrTypename);
            if ( !constructor ) {
                Fire.error('[addComponent] Failed to get class "%s"');
                if (_requiringFrames.length > 0) {
                    Fire.error('You should not add component when the scripts are still loading.', typeOrTypename);
                }
                return null;
            }
        }
        else {
            if ( !typeOrTypename ) {
                Fire.error('[addComponent] Type must be non-nil');
                return null;
            }
            constructor = typeOrTypename;
        }
        if (this._objFlags & Destroying) {
            Fire.error('isDestroying');
            return null;
        }
        if (typeof constructor !== 'function') {
            Fire.error("The component to add must be a constructor");
            return null;
        }
        var component = new constructor();
        component.entity = this;
        this._components.push(component);

        if (this._activeInHierarchy) {
            // call onLoad/onEnable
            component._onEntityActivated(true);
        }

        if (editorCallback.onComponentAdded) {
            editorCallback.onComponentAdded(this, component);
        }
        return component;
    },

    /**
     * Returns the component of supplied type if the entity has one attached, null if it doesn't. You can also get component in the entity by passing in the name of the script.
     *
     * @method getComponent
     * @param {function|string} typeOrName
     * @return {Component}
     */
    getComponent: function (typeOrTypename) {
        if ( !typeOrTypename ) {
            Fire.error('Argument must be non-nil');
            return;
        }
        var constructor;
        if (typeof typeOrTypename === 'string') {
            constructor = JS.getClassByName(typeOrTypename);
        }
        else {
            constructor = typeOrTypename;
        }
        for (var c = 0; c < this._components.length; ++c) {
            var component = this._components[c];
            if (component instanceof constructor) {
                return component;
            }
        }
        return null;
    },

    _removeComponent: function (component) {
        /*if (!component) {
            Fire.error('Argument must be non-nil');
            return;
        }*/
        if (!(this._objFlags & Destroying)) {
            //if (component.onHierarchyChanged) {
            //    this.transform._removeListener(component);
            //}
            var i = this._components.indexOf(component);
            if (i !== -1) {
                this._components.splice(i, 1);
                component.entity = null;
                if (editorCallback.onComponentRemoved) {
                    editorCallback.onComponentRemoved(this, component);
                }
            }
            else if (component.entity !== this) {
                Fire.error("Component not owned by this entity");
            }
        }
    },

    ////////////////////////////////////////////////////////////////////
    // hierarchy methods
    ////////////////////////////////////////////////////////////////////

    /**
     * Finds an entity by name in all children of this entity. This function will still returns the entity even if it is inactive.
     * It is recommended to not use this function every frame instead cache the result at startup.
     *
     * @method find
     * @param {string} path
     * @return {Entity} - If not found, null will be returned.
     * @beta
     */
    find: function (path) {
        if (!path && path !== '') {
            Fire.error('Argument must be non-nil');
            return;
        }
        if (path[0] === '/') {
            Fire.error("Path should not start with a '/' character, please use \"Fire.Entity.find\" instead");
            return;
        }
        var nameList = path.split('/');

        var match = this;
        var t = 0, len = 0, children = null, subEntity = null;
        for (var i = 0; i < nameList.length; i++) {
            var name = nameList[i];
            if (name === '..') {
                if (!match) {
                    return null;
                }
                match = match._parent;
            }
            else {
                if (!match) {
                    children = Engine._scene.entities;
                }
                else {
                    children = match._children;
                }
                match = null;
                for (t = 0, len = children.length; t < len; ++t) {
                    subEntity = children[t];
                    if (subEntity.name === name) {
                        match = subEntity;
                    }
                }
                if (!match) {
                    return null;
                }
            }
        }
        return match;
    },

    /**
     * Returns an entity child by index.
     *
     * @method getChild
     * @param {number} index
     * @return {Entity} - If not found, undefined will be returned.
     */
    getChild: function (index) {
        return this._children[index];
    },

    /**
     * Returns a new arrays of all children.
     *
     * @method getChildren
     * @return {Entity[]}
     */
    getChildren: function () {
        return this._children.slice();
    },

    /**
     * Is this entity a child of the parent?
     *
     * @method isChildOf
     * @param {Entity} parent
     * @return {boolean} - Returns true if this entity is a child, deep child or identical to the given entity.
     */
    isChildOf: function (parent) {
        var child = this;
        do {
            if (child === parent) {
                return true;
            }
            child = child._parent;
        }
        while (child);
        return false;
    },

    /**
     * Get the sibling index.
     *
     * NOTE: If this entity does not have parent and not belongs to the current scene,
     *       The return value will be -1
     *
     * @method getSiblingIndex
     * @return {number}
     */
    getSiblingIndex: function () {
        if (this._parent) {
            return this._parent._children.indexOf(this);
        }
        else {
            return Engine._scene.entities.indexOf(this);
        }
    },

    /**
     * Get the indexed sibling.
     *
     * @method getSibling
     * @param {number} index
     * @return {Entity} - If not found, undefined will be returned.
     */
    getSibling: function (index) {
        if (this._parent) {
            return this._parent._children[index];
        }
        else {
            return Engine._scene.entities[index];
        }
    },

    /**
     * Set the sibling index of this entity.
     *
     * @method setSiblingIndex
     * @param {number} index
     */
    setSiblingIndex: function (index) {
        var array = this._parent ? this._parent._children : Engine._scene.entities;
        var item = this;
        index = index !== -1 ? index : array.length - 1;
        var oldIndex = array.indexOf(item);
        if (index !== oldIndex) {
            array.splice(oldIndex, 1);
            if (index < array.length) {
                array.splice(index, 0, item);
            }
            else {
                array.push(item);
            }
            // callback
            Engine._renderContext.onEntityIndexChanged(this, oldIndex, index);
            if (editorCallback.onEntityIndexChanged) {
                editorCallback.onEntityIndexChanged(this, oldIndex, index);
            }
            //this._onHierarchyChanged(this, this.parent);
        }
    },

    /**
     * Move the entity to the top.
     *
     * @method setAsFirstSibling
     */
    setAsFirstSibling: function () {
        this.setSiblingIndex(0);
    },

    /**
     * Move the entity to the bottom.
     *
     * @method setAsLastSibling
     */
    setAsLastSibling: function () {
        this.setSiblingIndex(-1);
    },

    ////////////////////////////////////////////////////////////////////
    // other methods
    ////////////////////////////////////////////////////////////////////

    _onActivatedInHierarchy: function (value) {
        this._activeInHierarchy = value;

        // 当引入DestroyImmediate后，_components的元素有可能会在遍历过程中变少，需要复制一个新的数组，或者做一些标记
        // var components = this._components.slice();

        // component有可能在onEnable时增加，而新增的component已经onEnable了，所以这里事先记下长度，以免重复调用
        var countBefore = this._components.length;
        for (var c = 0; c < countBefore; ++c) {
            var component = this._components[c];
            component._onEntityActivated(value);
        }
        // activate children recursively
        for (var i = 0, len = this.childCount; i < len; ++i) {
            var entity = this._children[i];
            if (entity._active) {
                entity._onActivatedInHierarchy(value);
            }
        }
    },

    _deactivateChildComponents: function () {
        // 和 _onActivatedInHierarchy 类似但不修改 this._activeInHierarchy
        var countBefore = this._components.length;
        for (var c = 0; c < countBefore; ++c) {
            var component = this._components[c];
            component._onEntityActivated(false);
        }
        // deactivate children recursively
        for (var i = 0, len = this.childCount; i < len; ++i) {
            var entity = this._children[i];
            if (entity._active) {
                entity._deactivateChildComponents();
            }
        }
    },

    _onHierarchyChanged: function (oldParent) {
        var activeInHierarchyBefore = this._active && (!oldParent || oldParent._activeInHierarchy);
        var shouldActiveNow = this._active && (!this._parent || this._parent._activeInHierarchy);
        if (activeInHierarchyBefore !== shouldActiveNow) {
            this._onActivatedInHierarchy(shouldActiveNow);
        }
    },

    _instantiate: function (position, rotation) {
        // 临时实现版本，之后应该不拷贝scene object
        var oldParent = this._parent;
        this._parent = null;
        var clone = Fire._doInstantiate(this);
        this._parent = oldParent;
        // init
        if (Engine.isPlaying) {
            clone._name = this._name + '(Clone)';
        }
        if (position) {
            clone.transform._position = position;
        }
        if (rotation) {
            clone.transform._rotation = rotation;
        }
        if (Engine._scene) {
            Engine._scene.appendRoot(clone);
        }

        // invoke callbacks
        Engine._renderContext.onEntityCreated(clone, true);
        if (editorCallback.onEntityCreated) {
            editorCallback.onEntityCreated(clone);
        }
        // activate components
        if (clone._active) {
            clone._onActivatedInHierarchy(true);
        }

        return clone;
    }
});

////////////////////////////////////////////////////////////////////
// static
////////////////////////////////////////////////////////////////////

/**
 * The temp property that indicates the current creating entity should
 * binded with supplied object flags. This property only used in editor.
 *
 * @property _defaultFlags
 * @type {number}
 * @default 0
 * @static
 * @private
 */
Entity._defaultFlags = 0;

/**
 * Finds an entity by hierarchy path, the path is case-sensitive, and must start with a '/' character.
 * It will traverse the hierarchy by splitting the path using '/' character.
 * It is recommended to not use this function every frame instead cache the result at startup.
 *
 * @method find
 * @param {string} path
 * @return {Entity} the entity or null if not found
 * @static
 */
Entity.find = function (path) {
    if (!path && path !== '') {
        Fire.error('Argument must be non-nil');
        return null;
    }
    if (path[0] !== '/') {
        Fire.error("Path must start with a '/' character");
        return null;
    }
    return Engine._scene.findEntity(path);
};

Fire.Entity = Entity;

var Scene = (function () {

    var Scene = Fire.Class({
        name: "Fire.Scene",
        extends: Asset,

        properties: {
            /**
             * root entities
             * @property entities
             * @type {Entity[]}
             */
            entities: [],

            /**
             * the active camera
             * @property camera
             * @type {Camera}
             */
            camera: null
        }
    });

    ////////////////////////////////////////////////////////////////////
    // traversal operations
    ////////////////////////////////////////////////////////////////////

    var visitOperationTmpl = "if(c._enabled && c._FUNC_) c._FUNC_();";
        visitOperationTmpl =
           "if (c._enabled && c._FUNC_ && " +
           "   (Fire.Engine.isPlaying || Fire.attr(c,'executeInEditMode')) ) {" +
           "    execInTryCatch(c);" +
           "}";
    // 当引入DestroyImmediate后，entity和component可能会在遍历过程中变少，需要复制一个新的数组，或者做一些标记
    var visitFunctionTmpl = "\
(function(e){\
	var i, len=e._components.length;\
	for(i=0;i<len;++i){\
		var c=e._components[i];\
		" + visitOperationTmpl + "\
	}\
	var cs=e._children;\
	for(i=0,len=cs.length;i<len;++i){\
		var sub=cs[i];\
		if(sub._active) _FUNC_Recursively(sub);\
	}\
})";

    function execInTryCatch (c) {
        try {
            c._FUNC_();
        }
        catch (e) {
            Fire._throw(e);
        }
    }
    visitFunctionTmpl = "(function () {" +
                            execInTryCatch +
                            "return " + visitFunctionTmpl +
                        "})()";
    // jshint evil: true
    var updateRecursively = eval(visitFunctionTmpl.replace(/_FUNC_/g, 'update'));
    var lateUpdateRecursively = eval(visitFunctionTmpl.replace(/_FUNC_/g, 'lateUpdate'));
    var onPreRenderRecursively = eval(visitFunctionTmpl.replace(/_FUNC_/g, 'onPreRender'));
    // jshint evil: false

    Scene.prototype.update = function () {
        // call update
        var entities = this.entities;
        var i = 0, len = entities.length;
        // invoke onStart
        // TODO: 使用一个数组将需要调用的 onStart 存起来，避免递归遍历
        for (; i < len; ++i) {
            Component._invokeStarts(entities[i]);
        }
        // invoke update
        for (i = 0, len = entities.length; i < len; ++i) {
            if (entities[i]._active) {
                updateRecursively(entities[i]);
            }
        }
        // invoke lateUpdate
        for (i = 0, len = entities.length; i < len; ++i) {
            if (entities[i]._active) {
                lateUpdateRecursively(entities[i]);
            }
        }
    };

    Scene.prototype.render = function (renderContext) {
        Engine._curRenderContext = renderContext;

        // updateTransform
        this.updateTransform(renderContext.camera || this.camera);

        // call onPreRender
        var entities = this.entities;
        for (var i = 0, len = entities.length; i < len; ++i) {
            if (entities[i]._active) {
                onPreRenderRecursively(entities[i]);
            }
        }

        // render
        renderContext.render();

        Engine._curRenderContext = null;
    };

    ////////////////////////////////////////////////////////////////////
    // other functions
    ////////////////////////////////////////////////////////////////////

    Scene.prototype.updateTransform = function (camera) {
        var entities = this.entities;
        var i, len;
        if (camera) {
            // transform by camera
            var mat = new Matrix23();
            var camPos = new Vec2();
            camera._calculateTransform(mat, camPos);
            var offsetX = -camPos.x;
            var offsetY = -camPos.y;
            for (i = 0, len = entities.length; i < len; ++i) {
                var pos = entities[i].transform._position;
                var x = pos.x;
                var y = pos.y;
                pos.x += offsetX;
                pos.y += offsetY;
                entities[i].transform._updateTransform(mat);
                pos.x = x;
                pos.y = y;
            }
        }
        else {
            // transform
            for (i = 0, len = entities.length; i < len; ++i) {
                entities[i].transform._updateRootTransform();
            }
        }
    };

    Scene.prototype.appendRoot = function (_entity) {
        this.entities.push(_entity);
    };

    Scene.prototype.removeRoot = function (_entity) {
        // TODO: performence test
        var entities = this.entities;
        if (entities.length > 0 && entities[entities.length - 1] === _entity) {
            entities.pop();
            return;
        }
        var index = entities.indexOf(_entity);
        if (index !== -1) {
            entities.splice(index, 1);
        }
        else {
            Fire.error('entity ' + _entity + ' not contains in roots of hierarchy, ' +
                       'is may caused if entity not destroyed immediate before current scene changed');
        }
    };

    Scene.prototype.findEntity = function (path) {
        var nameList = path.split('/');
        var match = null;

        // visit root entities
        var name = nameList[1];     // skip first '/'
        var entities = this.entities;
        for (var i = 0; i < entities.length; i++) {
            if (entities[i].isValid && entities[i]._name === name) {
                match = entities[i];
                break;
            }
        }
        if (!match) {
            return null;
        }

        // parse path
        var n = 2;                  // skip first '/' and roots
        for (n; n < nameList.length; n++) {
            name = nameList[n];
            // visit sub entities
            var children = match._children;
            match = null;
            for (var t = 0, len = children.length; t < len; ++t) {
                var subEntity = children[t];
                if (subEntity.name === name) {
                    match = subEntity;
                    break;
                }
            }
            if (!match) {
                return null;
            }
        }

        return match;
    };

    Scene.prototype.activate = function () {
        // active entities, invoke onLoad and onEnable
        var entities = this.entities;
        var i = 0, len = entities.length;
        for (; i < len; ++i) {
            var entity = entities[i];
            if (entity._active) {
                entity._onActivatedInHierarchy(true);
            }
        }
        if (Engine.isPlaying) {
            // invoke onStart
            for (i = 0, len = entities.length; i < len; ++i) {
                Component._invokeStarts(entities[i]);
            }
        }
    };

    Scene.prototype.destroy = function () {
        var entities = this.entities;
        for (var i = 0, len = entities.length; i < len; ++i) {
            var entity = entities[i];
            if (entity.isValid) {
                if (entity._objFlags & DontDestroy) {
                    Engine._dontDestroyEntities.push(entity);
                }
                else {
                    entity.destroy();
                }
            }
        }
        Asset.prototype.destroy.call(this);
    };

    return Scene;
})();

Fire._Scene = Scene;


/**
 * The manager scheduling resources loading
 * - It will:
 *   - select registered loader
 *   - merge same url request
 *   - limit the max concurrent request
 * - It will NOT:
 *   - cache what has being loaded
 *   - load depends of resource
 * @class LoadManager
 * @static
 */
var LoadManager = (function () {

    function getBuiltinRawTypes () {
        return {
            image: {
                loader: ImageLoader,
                defaultExtname: '.host'
            },
            json: {
                loader: JsonLoader,
                defaultExtname: '.json'
            },
            text: {
                loader: TextLoader,
                defaultExtname: '.txt'
            }
        };
    }

    var urlToCallbacks = new Fire.CallbacksInvoker();

    /**
     * list of elements to load, the element type is {
     *     url: url,
     *     loader: loader,
     *     callback: callback,
     * }
     */
    var loadQueue = [];

    var loadNext = function () {
        if (LoadManager._curConcurrent >= LoadManager.maxConcurrent) {
            Fire.error('too many concurrent requests');
            return;
        }
        var nextOne = loadQueue.pop();
        if (nextOne) {
            doLoad(nextOne.loader, nextOne.url, nextOne.callback);
        }
    };

    function doLoad (loader, url, callback) {
        LoadManager._curConcurrent += 1;
        loader(url, function doLoadCB (error, asset) {
            callback(error, asset);
            LoadManager._curConcurrent = Math.max(0, LoadManager._curConcurrent - 1);
            loadNext();
        });
    }

    var LoadManager = {

        /**
         * Max allowed concurrent request count
         * @property maxConcurrent
         * @type {number}
         * @default 2
         */
        maxConcurrent: 2,

        /**
         * Current concurrent request count
         * @property _curConcurrent
         * @type {number}
         * @readOnly
         */
        _curConcurrent: 0,

        /**
         * NOTE: Request the same url with different loader is disallowed
         * @method loadByLoader
         * @param {function} loader
         * @param {string} url
         * @param {function} callback
         * @param {string} callback.param error - null or the error info
         * @param {any} callback.param data - the loaded data
         * @private
         */
        loadByLoader: function (loader, url, callback) {
            if (urlToCallbacks.add(url, callback)) {
                var callbackBundle = urlToCallbacks.bindKey(url, true);
                if (this._curConcurrent < this.maxConcurrent) {
                    doLoad(loader, url, callbackBundle);
                }
                else {
                    loadQueue.push({
                        url: url,
                        loader: loader,
                        callback: callbackBundle
                    });
                }
            }
        },

        /**
         * @method load
         * @param {string} url
         * @param {string} rawType
         * @param {string} [rawExtname]
         * @param {function} callback
         * @param {string} callback.param error - null or the error info
         * @param {any} callback.param data - the loaded data
         * @private
         */
        load: function (url, rawType, rawExtname, callback) {
            if (typeof rawExtname === 'function') {
                callback = rawExtname;
            }
            var typeInfo = this._rawTypes[rawType];
            if (typeInfo) {
                var extname = rawExtname ? ('.' + rawExtname) : typeInfo.defaultExtname;
                if (extname) {
                    var rawUrl = url + extname;
                    this.loadByLoader(typeInfo.loader, rawUrl, callback);
                }
                else {
                    callback('Undefined extname for the raw ' + rawType + ' file of ' + url, null);
                }
            }
            else {
                callback('Unknown raw type "' + rawType + '" of ' + url, null);
            }
        },

        _rawTypes: getBuiltinRawTypes(),

        /**
         * @method registerRawTypes
         * @param {string} rawType
         * @param {function} loader
         * @param {string} defaultExtname
         */
        registerRawTypes: function (rawType, loader, defaultExtname) {
            if (!rawType) {
                Fire.error('[AssetLibrary.registerRawTypes] rawType must be non-nil');
                return;
            }
            if (typeof rawType !== 'string') {
                Fire.error('[AssetLibrary.registerRawTypes] rawType must be string');
                return;
            }
            if (!loader) {
                Fire.error('[AssetLibrary.registerRawTypes] loader must be non-nil');
                return;
            }
            if (typeof loader !== 'function') {
                Fire.error('[AssetLibrary.registerRawTypes] loader must be function');
                return;
            }
            if (this._rawTypes[rawType]) {
                Fire.error('rawType "%s" has already defined', rawType);
                return;
            }
            if (defaultExtname && defaultExtname[0] !== '.') {
                defaultExtname = '.' + defaultExtname;
            }
            this._rawTypes[rawType] = {
                loader: loader,
                defaultExtname: defaultExtname
            };
        },

        reset: function () {
            this._rawTypes = getBuiltinRawTypes();
        },
        
        isLoading: function (url, alsoCheckRaw) {
            if (this._curConcurrent === 0) {
                return false;
            }
            if (urlToCallbacks.has(url)) {
                return true;
            }
            if (alsoCheckRaw) {
                for (var u in urlToCallbacks._callbackTable) {
                    if (u.indexOf(url) === 0) {
                        return true;
                    }
                }
            }
            return false;
        },
        _loadFromXHR: _LoadFromXHR
    };

    LoadManager._urlToCallbacks = urlToCallbacks;

    return LoadManager;
})();

Fire.LoadManager = LoadManager;

/**
 * The asset library which managing loading/unloading assets in project.
 *
 * @class AssetLibrary
 * @static
 */
var AssetLibrary = (function () {

    // configs

    var _libraryBase = '';

    // variables

    // the loading uuid's callbacks
    var _uuidToCallbacks = new Fire.CallbacksInvoker();

    // temp deserialize info
    var _tdInfo = new Fire._DeserializeInfo();

    // create a loading context which reserves all relevant parameters
    function LoadingHandle (readMainCache, writeMainCache) {
        this.readMainCache = readMainCache;
        this.writeMainCache = writeMainCache;
        var needIndieCache = !(this.readMainCache && this.writeMainCache);
        this.taskIndieCache = needIndieCache ? {} : null;
    }
    LoadingHandle.prototype.readCache = function (uuid) {
        if (this.readMainCache && this.writeMainCache) {
            return AssetLibrary._uuidToAsset[uuid];
        }
        else {
            if (this.readMainCache) {
                // writeMainCache == false
                return AssetLibrary._uuidToAsset[uuid] || this.taskIndieCache[uuid];
            }
            else {
                return this.taskIndieCache[uuid];
            }
        }
    };
    LoadingHandle.prototype.writeCache = function (uuid, asset) {
        if (this.writeMainCache) {
            AssetLibrary._uuidToAsset[uuid] = asset;
        }
        if (this.taskIndieCache) {
            this.taskIndieCache[uuid] = asset;
        }
    };

    // publics

    var AssetLibrary = {

        /**
         * @method loadAsset
         * @param {string} uuid
         * @param {function} callback
         * @param {string} callback.param error - null or the error info
         * @param {Asset} callback.param data - the loaded asset or null
         * @param {boolean} [readMainCache=true] - If false, the asset and all its depends assets will reload and create new instances from library.
         * @param {boolean} [writeMainCache=true] - If true, the result will cache to AssetLibrary, and MUST be unload by user manually.
         * @param {Asset} [existingAsset] - load to existing asset, this argument is only available in editor
         * @private
         */
        loadAsset: function (uuid, callback, readMainCache, writeMainCache, existingAsset) {
            readMainCache = typeof readMainCache !== 'undefined' ? readMainCache : true;
            writeMainCache = typeof writeMainCache !== 'undefined' ? writeMainCache : true;

            var handle = new LoadingHandle(readMainCache, writeMainCache);
            this._loadAssetByUuid(uuid, callback, handle, existingAsset);
        },

        _LoadingHandle: LoadingHandle,

        /**
         * !#zh uuid加载流程：
         * 1. 查找_uuidToAsset，如果已经加载过，直接返回
         * 2. 查找_uuidToCallbacks，如果已经在加载，则注册回调，直接返回
         * 3. 如果没有url，则将uuid直接作为路径
         * 4. 递归加载Asset及其引用到的其它Asset
         *
         * @method _loadAssetByUuid
         * @param {string} uuid
         * @param {AssetLibrary~loadCallback} callback - the callback to receive the asset, can be null
         * @param {LoadingHandle} handle - the loading context which reserves all relevant parameters
         * @param {Asset} [existingAsset] - load to existing asset, this argument is only available in editor
         * @private
         */
        _loadAssetByUuid: function (uuid, callback, handle, existingAsset) {
            if (typeof uuid !== 'string') {
                if (callback) {
                    callback('[AssetLibrary] uuid must be string', null);
                }
                return;
            }
            // step 1
            if ( !existingAsset ) {
                var asset = handle.readCache(uuid);
                if (asset) {
                    if (callback) {
                        callback(null, asset);
                    }
                    return;
                }
            }

            // step 2
            // 如果必须重新加载，则不能合并到到 _uuidToCallbacks，否则现有的加载成功后会同时触发回调，
            // 导致提前返回的之前的资源。
            var canShareLoadingTask = handle.readMainCache && !existingAsset;
            if ( canShareLoadingTask && !_uuidToCallbacks.add(uuid, callback) ) {
                // already loading
                return;
            }

            // step 4
            var url = _libraryBase + uuid.substring(0, 2) + Fire.Path.sep + uuid;

            // step 5
            LoadManager.loadByLoader(JsonLoader, url,
                function (error, json) {
                    function onDeserializedWithDepends (err, asset) {
                        if (asset) {
                            asset._uuid = uuid;
                            handle.writeCache(uuid, asset);
                        }
                        if ( canShareLoadingTask ) {
                            _uuidToCallbacks.invokeAndRemove(uuid, err, asset);
                        }
                        else if (callback) {
                            callback(err, asset);
                        }
                    }
                    if (json) {
                        AssetLibrary._deserializeWithDepends(json, url, onDeserializedWithDepends, handle, existingAsset);
                    }
                    else {
                        onDeserializedWithDepends(error, null);
                    }
                }
            );
        },

        /**
         * @method loadJson
         * @param {string|object} json
         * @param {function} callback
         * @param {string} callback.param error - null or the error info
         * @param {object} callback.param data - the loaded object or null
         * @param {boolean} [dontCache=false] - If false, the result will cache to AssetLibrary, and MUST be unload by user manually.
         * @private
         */
        loadJson: function (json, callback, dontCache) {
            var handle = new LoadingHandle(!dontCache, !dontCache);
            this._deserializeWithDepends(json, '', callback, handle);
        },

        /**
         * @method _deserializeWithDepends
         * @param {string|object} json
         * @param {string} url
         * @param {function} callback
         * @param {string} callback.param error - null or the error info
         * @param {object} callback.param data - the loaded object or null
         * @param {object} handle - the loading context which reserves all relevant parameters
         * @param {Asset} [existingAsset] - existing asset to reload
         * @private
         */
        _deserializeWithDepends: function (json, url, callback, handle, existingAsset) {
            // deserialize asset
            var isScene = json && json[0] && json[0].__type__ === JS._getClassId(Scene);
            var classFinder = isScene ? Fire._MissingScript.safeFindClass : function (id) {
                var cls = JS._getClassById(id);
                if (cls) {
                    return cls;
                }
                Fire.warn('Can not get class "%s"', id);
                return Object;
            };
            Engine._canModifyCurrentScene = false;
            var asset = Fire.deserialize(json, _tdInfo, {
                classFinder: classFinder,
                target: existingAsset
            });
            Engine._canModifyCurrentScene = true;

            // load depends
            var pendingCount = _tdInfo.uuidList.length;

            // load raw
            var rawProp = _tdInfo.rawProp;     // _tdInfo不能用在回调里！
            if (rawProp) {
                // load depends raw objects
                var attrs = Fire.attr(asset.constructor, _tdInfo.rawProp);
                var rawType = attrs.rawType;
                ++pendingCount;
                LoadManager.load(url, rawType, asset._rawext, function onRawObjLoaded (error, raw) {
                    if (error) {
                        Fire.error('[AssetLibrary] Failed to load %s of %s. %s', rawType, url, error);
                    }
                    asset[rawProp] = raw;
                    --pendingCount;
                    if (pendingCount === 0) {
                        callback(null, asset);
                    }
                });
            }

            if (pendingCount === 0) {
                callback(null, asset);
            }

            /*
             如果依赖的所有资源都要重新下载，批量操作时将会导致同时执行多次重复下载。优化方法是增加一全局事件队列，
             队列保存每个任务的注册，启动，结束事件，任务从注册到启动要延迟几帧，每个任务都存有父任务。
             这样通过队列的事件序列就能做到合并批量任务。
             如果依赖的资源不重新下载也行，但要判断是否刚好在下载过程中，如果是的话必须等待下载完成才能结束本资源的加载，
             否则外部获取到的依赖资源就会是旧的。
             */

            // AssetLibrary._loadAssetByUuid 的回调有可能在当帧也可能延后执行，这里要判断是否由它调用 callback，
            // 否则 callback 可能会重复调用
            var invokeCbByDepends = false;
            // load depends assets
            for (var i = 0, len = _tdInfo.uuidList.length; i < len; i++) {
                var dependsUuid = _tdInfo.uuidList[i];
                if (existingAsset) {
                    var existingDepends = _tdInfo.uuidObjList[i][_tdInfo.uuidPropList[i]];
                    if (existingDepends && existingDepends._uuid === dependsUuid) {
                        var dependsUrl = _libraryBase + dependsUuid.substring(0, 2) + Fire.Path.sep + dependsUuid;
                        if ( !LoadManager.isLoading(dependsUrl, true) ) {
                            // 如果有依赖但依赖不在加载过程中就直接略过
                            --pendingCount;
                        }
                        else {
                            // 等待依赖加载完成
                            (function (dependsUrl) {
                                var idToClear = setInterval(function () {
                                    if ( !LoadManager.isLoading(dependsUrl, true) ) {
                                        clearInterval(idToClear);
                                        --pendingCount;
                                        if (pendingCount === 0) {
                                            callback(null, asset);
                                        }
                                    }
                                }, 10);
                            })(dependsUrl);
                        }
                        continue;
                    }
                }
                var onDependsAssetLoaded = (function (dependsUuid, obj, prop) {
                    // create closure manually because its extremely faster than bind
                    return function (error, dependsAsset) {
                        if (error) {
                            if (Editor.AssetDB && Editor.AssetDB.isValidUuid(dependsUuid)) {
                                Fire.error('[AssetLibrary] Failed to load "%s", %s', dependsUuid, error);
                            }
                        }
                        //else {
                        //    dependsAsset._uuid = dependsUuid;
                        //}
                        // update reference
                        obj[prop] = dependsAsset;
                        // check all finished
                        --pendingCount;
                        if (pendingCount === 0) {
                            callback(null, asset);
                        }
                    };
                })( dependsUuid, _tdInfo.uuidObjList[i], _tdInfo.uuidPropList[i] );
                AssetLibrary._loadAssetByUuid(dependsUuid, onDependsAssetLoaded, handle);
                invokeCbByDepends = true;
            }

            if ( !invokeCbByDepends && pendingCount === 0) {
                callback(null, asset);
            }
            // _tdInfo 是用来重用临时对象，每次使用后都要重设，这样才对 GC 友好。
            _tdInfo.reset();
        },

        /**
         * Get the exists asset by uuid.
         *
         * @method getAssetByUuid
         * @param {string} uuid
         * @return {Asset} - the existing asset, if not loaded, just returns null.
         * @private
         */
        getAssetByUuid: function (uuid) {
            return AssetLibrary._uuidToAsset[uuid] || null;
        },

        /**
         * @callback AssetLibrary~loadCallback
         * @param {Asset} asset - if failed, asset will be null
         * @param {string} [error] - error info, if succeed, error will be empty or nil
         */

        /**
         * !#en Kill references to the asset so it can be garbage collected.
         * Fireball will reload the asset from disk or remote if loadAssetByUuid being called again.
         * You rarely use this function in scripts, since it will be called automatically when the Asset is destroyed.
         * !#zh 手动卸载指定的资源，这个方法会在 Asset 被 destroy 时自动调用，一般不需要用到这个方法。卸载以后，Fireball 可以重新从硬盘或网络加载这个资源。
         *
         * 如果还有地方引用到asset，除非 destroyImmediated 为true，否则不应该执行这个方法，因为那样可能会导致 asset 被多次创建。
         *
         * @method unloadAsset
         * @param {Asset|string} assetOrUuid
         * @param {boolean} [destroyImmediate=false] When destroyImmediate is true, if there are objects
         *                                           referencing the asset, the references will become invalid.
         */
        unloadAsset: function (assetOrUuid, destroyImmediate) {
            var asset;
            if (typeof assetOrUuid === 'string') {
                asset = AssetLibrary._uuidToAsset[assetOrUuid];
            }
            else {
                asset = assetOrUuid;
            }
            if (asset) {
                if (destroyImmediate && asset.isValid) {
                    asset.destroy();
                    // simulate destroy immediate
                    FObject._deferredDestroy();
                }
                delete AssetLibrary._uuidToAsset[asset._uuid];
            }
        },

        /**
         * init the asset library
         * @method init
         * @param {string} libraryPath
         */
        init: function (libraryPath) {
            if (_libraryBase && !Fire.isUnitTest) {
                Fire.error('AssetLibrary has already been initialized!');
                return;
            }
            _libraryBase = Fire.Path.setEndWithSep(libraryPath);
            //Fire.log('[AssetLibrary] library: ' + _libraryBase);
        }

        ///**
        // * temporary flag for deserializing assets
        // * @property {boolean} Fire.AssetLibrary.isLoadingAsset
        // */
        //isLoadingAsset: false,
    };

    // unload asset if it is destoryed

    /**
     * !#en Caches uuid to all loaded assets in scenes.
     *
     * !#zh 这里保存所有已经加载的场景资源，防止同一个资源在内存中加载出多份拷贝。
     *
     * 这里用不了WeakMap，在浏览器中所有加载过的资源都只能手工调用 unloadAsset 释放。
     *
     * 参考：
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap
     * https://github.com/TooTallNate/node-weak
     *
     * @property _uuidToAsset
     * @type {object}
     * @private
     */
    AssetLibrary._uuidToAsset = {};

    if (Asset.prototype._onPreDestroy) {
        Fire.error('_onPreDestroy of Asset has already defined');
    }
    Asset.prototype._onPreDestroy = function () {
        if (AssetLibrary._uuidToAsset[this._uuid] === this) {
            AssetLibrary.unloadAsset(this, false);
        }
    };

    return AssetLibrary;
})();

Fire.AssetLibrary = AssetLibrary;

var FireMouseEvent = Fire.MouseEvent;
//var FireKeyboardEvent = Fire.KeyboardEvent;

var EventRegister = {
    inputEvents: {
        // ref: http://www.w3.org/TR/DOM-Level-3-Events/#event-types-list
        keydown: {
            constructor: null,
            bubbles: true,
            cancelable: true
        },
        keyup: {
            constructor: null,
            bubbles: true,
            cancelable: true
        },
        click: {
            constructor: FireMouseEvent,
            bubbles: true,
            cancelable: true
        },
        dblclick: {
            constructor: FireMouseEvent,
            bubbles: true,
            cancelable: false
        },
        mousedown: {
            constructor: FireMouseEvent,
            bubbles: true,
            cancelable: true
        },
        mouseup: {
            constructor: FireMouseEvent,
            bubbles: true,
            cancelable: true
        },
        mousemove: {
            constructor: FireMouseEvent,
            bubbles: true,
            cancelable: true
        },
        //touchstart: {
        //    constructor: FireMouseEvent,
        //    bubbles: true,
        //    cancelable: true
        //},
        //touchend: {
        //    constructor: FireMouseEvent,
        //    bubbles: true,
        //    cancelable: true
        //},
        //touchmove: {
        //    constructor: FireMouseEvent,
        //    bubbles: true,
        //    cancelable: true
        //}
        mouseenter: {
            constructor: FireMouseEvent,
            bubbles: false,
            cancelable: false
        },
        mouseleave: {
            constructor: FireMouseEvent,
            bubbles: false,
            cancelable: false
        }
        //mouseout: {
        //    constructor: FireMouseEvent,
        //    bubbles: true,
        //    cancelable: true,
        //},
        //mouseover: {
        //    constructor: FireMouseEvent,
        //    bubbles: true,
        //    cancelable: true,
        //},
    }
};

Fire.EventRegister = EventRegister;

var Input = (function () {

    /**
     * Interface into the Input system.
     * @class Input
     * @static
     * @beta
     */
    var Input = {
        _eventListeners: new EventListeners(),
        _lastTarget: null
    };

    /**
     * Returns whether the current device supports touch input
     */
    Object.defineProperty(Input, 'hasTouch', {
        get: function () {
            return !!Engine._inputContext && Engine._inputContext.hasTouch;
        }
    });

    /**
     * !#en Register an callback of a specific input event type.
     *
     * For all supported event and type, please see [Input Events](/en/scripting/input-events)
     *
     * !#zh 注册输入事件的回调方法。
     *
     * 请参考：
     * - [获取用户输入](/zh/scripting/input)
     * - [输入事件列表](/zh/scripting/input-events)
     *
     * @method on
     * @param {string} type - eg. "keydown", "click"
     * @param {function} callback
     * @param {Event} callback.param event - the input event
     * @beta
     */
    Input.on = function (type, callback) {
        if (callback) {
            this._eventListeners.add(type, callback);
        }
        else {
            Fire.error('Callback must be non-nil');
        }
    };

    /**
     * Removes the callback previously registered with the same type and callback.
     * @method off
     * @param {string} type
     * @param {function} callback
     * @beta
     */
    Input.off = function (type, callback) {
        if (callback) {
            if (! this._eventListeners.remove(type, callback)) {
                Fire.warn('Callback not exists');
            }
        }
        else {
            Fire.error('Callback must be non-nil');
        }
    };

    Input._reset = function () {
        this._eventListeners = new EventListeners();
        this._lastTarget = null;
    };

    Input._dispatchMouseEvent = function (event, inputContext) {
        var camera = inputContext.renderContext.camera || Engine._scene.camera;
        var worldMousePos = camera.screenToWorld(new Vec2(event.screenX, event.screenY));
        var target = Engine._interactionContext.pick(worldMousePos);

        // dispatch global mouse event
        event.target = target;
        this._eventListeners.invoke(event);

        if (this._lastTarget && this._lastTarget !== target) {
            // mouse leave event
            var leaveEvent = event.clone();
            leaveEvent.type = 'mouseleave';
            leaveEvent.bubbles = EventRegister.inputEvents.mouseleave.bubbles;
            this._lastTarget.dispatchEvent(leaveEvent);
        }
        if (target) {
            // dispatch mouse event
            target.dispatchEvent(event);
            // mouse enter event
            if (this._lastTarget !== target) {
                var enterEvent = event.clone();
                enterEvent.type = 'mouseenter';
                enterEvent.bubbles = EventRegister.inputEvents.mouseenter.bubbles;
                target.dispatchEvent(enterEvent);
            }
        }
        this._lastTarget = target;
    };

    Input._dispatchEvent = function (event, inputContext) {
        if (event instanceof Fire.MouseEvent) {
            this._dispatchMouseEvent(event, inputContext);
        }
        else {
            // dispatch global event
            this._eventListeners.invoke(event);
        }
    };

    return Input;
})();

Fire.Input = Input;

if (Fire.isIOS) {
    Fire.LoadManager.load('empty','audio', 'mp3', function (err, data) {
        var isPlayed = false;
        window.addEventListener('touchstart', function listener () {
            if (isPlayed) {
                return;
            }
            isPlayed = true;
            var defaultSource = new Fire.AudioSource();
            var defaultClip = new Fire.AudioClip();
            defaultClip.rawData = data;
            defaultSource.clip = defaultClip;
            Fire.AudioContext.play(defaultSource);
            window.removeEventListener('touchstart', listener);
        });
    });
}

(function(){
    var UseWebAudio = (window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
    if (UseWebAudio) {
        return;
    }
    var AudioContext = {};

    // Audio状态可用数据足以开始播放
    var HAVE_ENOUGH_DATA = 4;

    function loader (url, callback, onProgress) {
        var audio = document.createElement("audio");

        if (Browser.type === Browser.BROWSER_TYPE_IE) {
            var checkReadyState = setInterval(function () {
                if(audio.readyState === HAVE_ENOUGH_DATA ) {
                    callback(null, audio);
                    clearInterval(checkReadyState);
                }
            }, 100);
        }
        else{
            audio.addEventListener("canplaythrough", function () {
                callback(null, audio);
            }, false);
        }

        audio.addEventListener('error', function (e) {
            callback('LoadAudioClip: "' + url +
                    '" seems to be unreachable or the file is empty. InnerMessage: ' + e + '\n This may caused by fireball-x/dev#267', null);
        }, false);

        audio.src = url;
    }

    Fire.LoadManager.registerRawTypes('audio', loader);

    AudioContext.initSource = function (target) {
        target._audio = null;
    };

    AudioContext.getCurrentTime = function (target) {
        if (target && target._audio && target._playing) {
            return target._audio.currentTime;
        }
        else {
            return 0;
        }
    };

    AudioContext.updateTime = function (target, value) {
        if (target && target._audio) {
            var duration = target._audio.duration;
            target._audio.currentTime = value;
        }
    };

    // 靜音
    AudioContext.updateMute = function (target) {
        if (!target || !target._audio) { return; }
        target._audio.muted = target.mute;
    };

    // 设置音量，音量范围是[0, 1]
    AudioContext.updateVolume = function (target) {
        if (!target || !target._audio) { return; }
        target._audio.volume = target.volume;
    };

    // 设置循环
    AudioContext.updateLoop = function (target) {
        if (!target || !target._audio) { return; }
        target._audio.loop = target.loop;
    };

    // 设置音频播放的速度
    AudioContext.updatePlaybackRate = function (target) {
        if ( !this.isPaused ) {
            this.pause(target);
            this.play(target);
        }
    };

    // 将音乐源节点绑定具体的音频buffer
    AudioContext.updateAudioClip = function (target) {
        if (!target || !target.clip) { return; }
        target._audio = target.clip.rawData;
    };

    // 暫停
    AudioContext.pause = function (target) {
        if (!target._audio) { return; }
        target._audio.pause();
    };

    // 停止
    AudioContext.stop = function (target) {
        if (!target._audio) { return; }
        target._audio.pause();
        target._audio.currentTime = 0;
        if(target._audio.onended) {
            target._audio.removeEventListener('ended', target._audio.onended);
        }
    };

    // 播放
    AudioContext.play = function (target, at) {
        if (!target || !target.clip || !target.clip.rawData) { return; }
        if (target._playing && !target._paused) { return; }
        this.updateAudioClip(target);
        this.updateVolume(target);
        this.updateLoop(target);
        this.updateMute(target);
        this.playbackRate = target.playbackRate;

        target._audio.play();

        target._audio.onended = function () {
            target._onPlayEnd().bind(target);
        }.bind(target);

        // 播放结束后的回调
        target._audio.addEventListener('ended', target._audio.onended);
    };

    // 获得音频剪辑的 buffer
    AudioContext.getClipBuffer = function (clip) {
        Fire.error("Audio does not contain the <Buffer> attribute!");
        return null;
    };

    // 以秒为单位 获取音频剪辑的 长度
    AudioContext.getClipLength = function (clip) {
        return clip.rawData.duration;
    };

    // 音频剪辑的长度
    AudioContext.getClipSamples = function (target) {
        Fire.error("Audio does not contain the <Samples> attribute!");
        return null;
    };

    // 音频剪辑的声道数
    AudioContext.getClipChannels = function (target) {
        Fire.error("Audio does not contain the <Channels> attribute!");
        return null;
    };

    // 音频剪辑的采样频率
    AudioContext.getClipFrequency = function (target) {
        Fire.error("Audio does not contain the <Frequency> attribute!");
        return null;
    };


    Fire.AudioContext = AudioContext;
})();


var AudioSource = (function () {

    /**
     * The audio source component.
     * @class AudioSource
     * @extends Component
     * @constructor
     */
    var AudioSource = Fire.Class({
        //
        name: "Fire.AudioSource",
        //
        extends: Fire.Component,
        //
        constructor: function () {
            // 声源暂停或者停止时候为false
            this._playing = false;
            // 来区分声源是暂停还是停止
            this._paused = false;

            this._startTime = 0;
            this._lastPlay = 0;

            this._buffSource = null;
            this._volumeGain = null;

            /**
             * The callback function which will be invoked when the audio stops
             * @property onEnd
             * @type {function}
             * @default null
             */
            this.onEnd = null;
        },
        properties: {
            /**
             * Is the audio source playing (Read Only)？
             * @property isPlaying
             * @type {boolean}
             * @readOnly
             * @default false
             */
            isPlaying: {
                get: function () {
                    return this._playing && !this._paused;
                },
                visible: false
            },
            /**
             * Is the audio source paused (Read Only)?
             * @property isPaused
             * @type {boolean}
             * @readOnly
             * @default false
             */
            isPaused:{
                get: function () {
                    return this._paused;
                },
                visible: false
            },
            /**
             * Playback position in seconds.
             * @property time
             * @type {number}
             * @default 0
             */
            time: {
                get: function () {
                    return Fire.AudioContext.getCurrentTime(this);
                },
                set: function (value) {
                    Fire.AudioContext.updateTime(this, value);
                },
                visible: false
            },
            _clip: {
                default: null,
                type: Fire.AudioClip
            },
            /**
             * The audio clip to play.
             * @property clip
             * @type {AudioClip}
             * @default null
             */
            clip:{
                get: function () {
                    return this._clip;
                },
                set: function (value) {
                    if (this._clip !== value) {
                        this._clip = value;
                        Fire.AudioContext.updateAudioClip(this);
                    }
                }
            },
            //
            _loop: false,
            /**
             * Is the audio source looping?
             * @property loop
             * @type {boolean}
             * @default false
             */
            loop: {
                get: function () {
                    return this._loop;
                },
                set: function (value) {
                    if (this._loop !== value) {
                        this._loop = value;
                        Fire.AudioContext.updateLoop(this);
                    }
                }
            },
            //
            _mute: false,
            /**
             * Is the audio source mute?
             * @property mute
             * @type {boolean}
             * @default false
             */
            mute: {
                get: function () {
                    return this._mute;
                },
                set: function (value) {
                    if (this._mute !== value) {
                        this._mute = value;
                        Fire.AudioContext.updateMute(this);
                    }
                }
            },
            //
            _volume: 1,
            /**
             * The volume of the audio source.
             * @property volume
             * @type {number}
             * @default 1
             */
            volume: {
                get: function () {
                    return this._volume;
                },
                set: function (value) {
                    if (this._volume !== value) {
                        this._volume = Math.clamp01(value);
                        Fire.AudioContext.updateVolume(this);
                    }
                },
                range: [0, 1]
            },
            //
            _playbackRate: 1.0,
            /**
             * The playback rate of the audio source.
             * @property playbackRate
             * @type {number}
             * @default 1
             */
            playbackRate: {
                get: function () {
                    return this._playbackRate;
                },
                set: function (value) {
                    if (this._playbackRate !== value) {
                        this._playbackRate = value;
                        if(this._playing) {
                            Fire.AudioContext.updatePlaybackRate(this);
                        }
                    }
                }
            },
            /**
             * If set to true, the audio source will automatically start playing on onLoad.
             * @property playOnLoad
             * @type {boolean}
             * @default true
             */
            playOnLoad: true
        },
        _onPlayEnd: function () {
            if ( this.onEnd ) {
                this.onEnd();
            }

            this._playing = false;
            this._paused = false;
        },
        /**
         * Pauses the clip.
         * @method pause
         */
        pause: function () {
            if ( this._paused )
                return;

            Fire.AudioContext.pause(this);
            this._paused = true;
        },
        /**
         * Plays the clip.
         * @method play
         */
        play: function () {
            if ( this._playing && !this._paused )
                return;

            if ( this._paused )
                Fire.AudioContext.play(this, this._startTime);
            else
                Fire.AudioContext.play(this, 0);

            this._playing = true;
            this._paused = false;
        },
        /**
         * Stops the clip
         * @method stop
         */
        stop: function () {
            if ( !this._playing ) {
                return;
            }

            Fire.AudioContext.stop(this);
            this._playing = false;
            this._paused = false;
        },
        //
        onLoad: function () {
            if (this._playing ) {
                this.stop();
            }
        },
        //
        onEnable: function () {
            if (this.playOnLoad) {
                this.play();
            }
        },
        //
        onDisable: function () {
            this.stop();
        }
    });

    //
    Fire.addComponentMenu(AudioSource, 'AudioSource');

    return AudioSource;
})();

Fire.AudioSource = AudioSource;

(function () {
    var NativeAudioContext = (window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
    if ( !NativeAudioContext ) {
        return;
    }

    // fix fireball-x/dev#365
    if (!Fire.nativeAC) {
        Fire.nativeAC = new NativeAudioContext();
    }

    // 添加safeDecodeAudioData的原因：https://github.com/fireball-x/dev/issues/318
    function safeDecodeAudioData(context, buffer, url, callback) {
        var timeout = false;
        var timerId = setTimeout(function () {
            callback('The operation of decoding audio data already timeout! Audio url: "' + url +
                     '". Set Fire.AudioContext.MaxDecodeTime to a larger value if this error often occur. ' +
                     'See fireball-x/dev#318 for details.', null);
        }, AudioContext.MaxDecodeTime);

        context.decodeAudioData(buffer,
            function (decodedData) {
                if (!timeout) {
                    callback(null, decodedData);
                    clearTimeout(timerId);
                }
            },
            function (e) {
                if (!timeout) {
                    callback(null, 'LoadAudioClip: "' + url +
                        '" seems to be unreachable or the file is empty. InnerMessage: ' + e);
                    clearTimeout(timerId);
                }
            }
        );
    }

    function loader(url, callback, onProgress) {
        var cb = callback && function (error, xhr) {
            if (xhr) {
                safeDecodeAudioData(Fire.nativeAC, xhr.response, url, callback);
            }
            else {
                callback('LoadAudioClip: "' + url +
               '" seems to be unreachable or the file is empty. InnerMessage: ' + error, null);
            }
        };
        Fire.LoadManager._loadFromXHR(url, cb, onProgress, 'arraybuffer');
    }

    Fire.LoadManager.registerRawTypes('audio', loader);

    var AudioContext = {};

    AudioContext.MaxDecodeTime = 4000;

    AudioContext.getCurrentTime = function (target) {
        if ( target._paused ) {
            return target._startTime;
        }

        if ( target._playing ) {
            return target._startTime + this.getPlayedTime(target);
        }

        return 0;
    };

    AudioContext.getPlayedTime = function (target) {
        return (Fire.nativeAC.currentTime - target._lastPlay) * target._playbackRate;
    };

    //
    AudioContext.updateTime = function (target, time) {
        target._lastPlay = Fire.nativeAC.currentTime;
        target._startTime = time;

        if ( target.isPlaying ) {
            this.pause(target);
            this.play(target);
        }
    };

    //
    AudioContext.updateMute = function (target) {
        if (!target._volumeGain) { return; }
        target._volumeGain.gain.value = target.mute ? -1 : (target.volume - 1);
    };

    // range [0,1]
    AudioContext.updateVolume = function (target) {
        if (!target._volumeGain) { return; }
        target._volumeGain.gain.value = target.volume - 1;
    };

    //
    AudioContext.updateLoop = function (target) {
        if (!target._buffSource) { return; }
        target._buffSource.loop = target.loop;
    };

    // bind buffer source
    AudioContext.updateAudioClip = function (target) {
        if ( target.isPlaying ) {
            this.stop(target,false);
            this.play(target);
        }
    };

    //
    AudioContext.updatePlaybackRate = function (target) {
        if ( !this.isPaused ) {
            this.pause(target);
            this.play(target);
        }
    };

    //
    AudioContext.pause = function (target) {
        if (!target._buffSource) { return; }

        target._startTime += this.getPlayedTime(target);
        target._buffSource.onended = null;
        target._buffSource.stop(0);
    };

    //
    AudioContext.stop = function ( target, ended ) {
        if (!target._buffSource) { return; }

        if ( !ended ) {
            target._buffSource.onended = null;
        }
        target._buffSource.stop(0);
    };

    //
    AudioContext.play = function ( target, at ) {
        if (!target.clip || !target.clip.rawData) { return; }

        // create buffer source
        var bufferSource = Fire.nativeAC.createBufferSource();

        // create volume control
        var gain = Fire.nativeAC.createGain();

        // connect
        bufferSource.connect(gain);
        gain.connect(Fire.nativeAC.destination);
        bufferSource.connect(Fire.nativeAC.destination);

        // init parameters
        bufferSource.buffer = target.clip.rawData;
        bufferSource.loop = target.loop;
        bufferSource.playbackRate.value = target.playbackRate;
        bufferSource.onended = target._onPlayEnd.bind(target);
        gain.gain.value = target.mute ? -1 : (target.volume - 1);

        //
        target._buffSource = bufferSource;
        target._volumeGain = gain;
        target._startTime = at || 0;
        target._lastPlay = Fire.nativeAC.currentTime;

        // play
        bufferSource.start( 0, this.getCurrentTime(target) );
    };

    // ===================

    //
    AudioContext.getClipBuffer = function (clip) {
        return clip.rawData;
    };

    //
    AudioContext.getClipLength = function (clip) {
        if (clip.rawData) {
            return clip.rawData.duration;
        }
        return -1;
    };

    //
    AudioContext.getClipSamples = function (clip) {
        if (clip.rawData) {
            return clip.rawData.length;
        }
        return -1;
    };

    //
    AudioContext.getClipChannels = function (clip) {
        if (clip.rawData) {
            return clip.rawData.numberOfChannels;
        }
        return -1;
    };

    //
    AudioContext.getClipFrequency = function (clip) {
        if (clip.rawData) {
            return clip.rawData.sampleRate;
        }
        return -1;
    };


    Fire.AudioContext = AudioContext;
})();

    // end of generated codes

    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = Fire;
        }
        exports.Fire = Fire;
    }
    else if (typeof define !== 'undefined' && define.amd) {
        define(Fire);
    }
    else {
        root.Fire = Fire;
        root.Editor = Editor;
    }
}).call(this);
